/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.xiaomi.cubedb.thrift;

import org.apache.commons.lang.builder.HashCodeBuilder;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

import com.twitter.util.Future;
import com.twitter.util.Function;
import com.twitter.util.Function2;
import com.twitter.util.Try;
import com.twitter.util.Return;
import com.twitter.util.Throw;
import com.twitter.finagle.thrift.DeserializeCtx;
import com.twitter.finagle.thrift.ThriftClientRequest;

public class CubeDBService {
  public interface Iface {
    public Response put(String key, ByteBuffer value) throws TException;
    public GetResult get(String key) throws TException;
    public MultipleGetResult multipleGet(List<String> keys) throws TException;
    public Response convertPut(String key, ByteBuffer value, CubeDBFunc classNameOfPut) throws TException;
    public GetResult convertGet(String key, ByteBuffer inputData, CubeDBFunc classNameOfConvert) throws TException;
    public MultipleGetResult convertMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, boolean isLocal) throws TException;
    public CombineGetResult combineMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfCombine, boolean isLocal) throws TException;
    public CombineGetResult combineMultipleFilter(List<String> includeKeys, List<String> excludeKeys, ByteBuffer inputData, CubeDBFunc classNameOfFilter, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfMerge, boolean isLocal) throws TException;
  }

  public interface AsyncIface {
    public void put(String key, ByteBuffer value, AsyncMethodCallback<AsyncClient.put_call> resultHandler) throws TException;
    public void get(String key, AsyncMethodCallback<AsyncClient.get_call> resultHandler) throws TException;
    public void multipleGet(List<String> keys, AsyncMethodCallback<AsyncClient.multipleGet_call> resultHandler) throws TException;
    public void convertPut(String key, ByteBuffer value, CubeDBFunc classNameOfPut, AsyncMethodCallback<AsyncClient.convertPut_call> resultHandler) throws TException;
    public void convertGet(String key, ByteBuffer inputData, CubeDBFunc classNameOfConvert, AsyncMethodCallback<AsyncClient.convertGet_call> resultHandler) throws TException;
    public void convertMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, boolean isLocal, AsyncMethodCallback<AsyncClient.convertMultipleGet_call> resultHandler) throws TException;
    public void combineMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfCombine, boolean isLocal, AsyncMethodCallback<AsyncClient.combineMultipleGet_call> resultHandler) throws TException;
    public void combineMultipleFilter(List<String> includeKeys, List<String> excludeKeys, ByteBuffer inputData, CubeDBFunc classNameOfFilter, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfMerge, boolean isLocal, AsyncMethodCallback<AsyncClient.combineMultipleFilter_call> resultHandler) throws TException;
  }

  public interface ServiceIface {
    public Future<Response> put(String key, ByteBuffer value);
    public Future<GetResult> get(String key);
    public Future<MultipleGetResult> multipleGet(List<String> keys);
    public Future<Response> convertPut(String key, ByteBuffer value, CubeDBFunc classNameOfPut);
    public Future<GetResult> convertGet(String key, ByteBuffer inputData, CubeDBFunc classNameOfConvert);
    public Future<MultipleGetResult> convertMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, boolean isLocal);
    public Future<CombineGetResult> combineMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfCombine, boolean isLocal);
    public Future<CombineGetResult> combineMultipleFilter(List<String> includeKeys, List<String> excludeKeys, ByteBuffer inputData, CubeDBFunc classNameOfFilter, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfMerge, boolean isLocal);
  }

  public static class Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public Response put(String key, ByteBuffer value) throws TException
    {
      send_put(key, value);
      return recv_put();
    }

    public void send_put(String key, ByteBuffer value) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("put", TMessageType.CALL, ++seqid_));
      put_args __args__ = new put_args();
      __args__.setKey(key);
      __args__.setValue(value);
      __args__.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Response recv_put() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "put failed: out of sequence response");
      }
      put_result result = new put_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "put failed: unknown result");
    }
    public GetResult get(String key) throws TException
    {
      send_get(key);
      return recv_get();
    }

    public void send_get(String key) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, ++seqid_));
      get_args __args__ = new get_args();
      __args__.setKey(key);
      __args__.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public GetResult recv_get() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get failed: out of sequence response");
      }
      get_result result = new get_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
    }
    public MultipleGetResult multipleGet(List<String> keys) throws TException
    {
      send_multipleGet(keys);
      return recv_multipleGet();
    }

    public void send_multipleGet(List<String> keys) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("multipleGet", TMessageType.CALL, ++seqid_));
      multipleGet_args __args__ = new multipleGet_args();
      __args__.setKeys(keys);
      __args__.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public MultipleGetResult recv_multipleGet() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "multipleGet failed: out of sequence response");
      }
      multipleGet_result result = new multipleGet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multipleGet failed: unknown result");
    }
    public Response convertPut(String key, ByteBuffer value, CubeDBFunc classNameOfPut) throws TException
    {
      send_convertPut(key, value, classNameOfPut);
      return recv_convertPut();
    }

    public void send_convertPut(String key, ByteBuffer value, CubeDBFunc classNameOfPut) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("convertPut", TMessageType.CALL, ++seqid_));
      convertPut_args __args__ = new convertPut_args();
      __args__.setKey(key);
      __args__.setValue(value);
      __args__.setClassNameOfPut(classNameOfPut);
      __args__.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Response recv_convertPut() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "convertPut failed: out of sequence response");
      }
      convertPut_result result = new convertPut_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "convertPut failed: unknown result");
    }
    public GetResult convertGet(String key, ByteBuffer inputData, CubeDBFunc classNameOfConvert) throws TException
    {
      send_convertGet(key, inputData, classNameOfConvert);
      return recv_convertGet();
    }

    public void send_convertGet(String key, ByteBuffer inputData, CubeDBFunc classNameOfConvert) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("convertGet", TMessageType.CALL, ++seqid_));
      convertGet_args __args__ = new convertGet_args();
      __args__.setKey(key);
      __args__.setInputData(inputData);
      __args__.setClassNameOfConvert(classNameOfConvert);
      __args__.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public GetResult recv_convertGet() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "convertGet failed: out of sequence response");
      }
      convertGet_result result = new convertGet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "convertGet failed: unknown result");
    }
    public MultipleGetResult convertMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, boolean isLocal) throws TException
    {
      send_convertMultipleGet(keys, inputData, classNameOfConvert, isLocal);
      return recv_convertMultipleGet();
    }

    public void send_convertMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, boolean isLocal) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("convertMultipleGet", TMessageType.CALL, ++seqid_));
      convertMultipleGet_args __args__ = new convertMultipleGet_args();
      __args__.setKeys(keys);
      __args__.setInputData(inputData);
      __args__.setClassNameOfConvert(classNameOfConvert);
      __args__.setIsLocal(isLocal);
      __args__.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public MultipleGetResult recv_convertMultipleGet() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "convertMultipleGet failed: out of sequence response");
      }
      convertMultipleGet_result result = new convertMultipleGet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "convertMultipleGet failed: unknown result");
    }
    public CombineGetResult combineMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfCombine, boolean isLocal) throws TException
    {
      send_combineMultipleGet(keys, inputData, classNameOfConvert, classNameOfCombine, isLocal);
      return recv_combineMultipleGet();
    }

    public void send_combineMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfCombine, boolean isLocal) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("combineMultipleGet", TMessageType.CALL, ++seqid_));
      combineMultipleGet_args __args__ = new combineMultipleGet_args();
      __args__.setKeys(keys);
      __args__.setInputData(inputData);
      __args__.setClassNameOfConvert(classNameOfConvert);
      __args__.setClassNameOfCombine(classNameOfCombine);
      __args__.setIsLocal(isLocal);
      __args__.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public CombineGetResult recv_combineMultipleGet() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "combineMultipleGet failed: out of sequence response");
      }
      combineMultipleGet_result result = new combineMultipleGet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "combineMultipleGet failed: unknown result");
    }
    public CombineGetResult combineMultipleFilter(List<String> includeKeys, List<String> excludeKeys, ByteBuffer inputData, CubeDBFunc classNameOfFilter, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfMerge, boolean isLocal) throws TException
    {
      send_combineMultipleFilter(includeKeys, excludeKeys, inputData, classNameOfFilter, classNameOfConvert, classNameOfMerge, isLocal);
      return recv_combineMultipleFilter();
    }

    public void send_combineMultipleFilter(List<String> includeKeys, List<String> excludeKeys, ByteBuffer inputData, CubeDBFunc classNameOfFilter, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfMerge, boolean isLocal) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("combineMultipleFilter", TMessageType.CALL, ++seqid_));
      combineMultipleFilter_args __args__ = new combineMultipleFilter_args();
      __args__.setIncludeKeys(includeKeys);
      __args__.setExcludeKeys(excludeKeys);
      __args__.setInputData(inputData);
      __args__.setClassNameOfFilter(classNameOfFilter);
      __args__.setClassNameOfConvert(classNameOfConvert);
      __args__.setClassNameOfMerge(classNameOfMerge);
      __args__.setIsLocal(isLocal);
      __args__.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public CombineGetResult recv_combineMultipleFilter() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "combineMultipleFilter failed: out of sequence response");
      }
      combineMultipleFilter_result result = new combineMultipleFilter_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "combineMultipleFilter failed: unknown result");
    }
  }

  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private final TAsyncClientManager clientManager;
      private final TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void put(String key, ByteBuffer value, AsyncMethodCallback<put_call> __resultHandler__) throws TException {
      checkReady();
      put_call __method_call__ = new put_call(key, value, __resultHandler__, this, super.protocolFactory, super.transport);
      manager.call(__method_call__);
    }

    public static class put_call extends TAsyncMethodCall {
      private String key;
      private ByteBuffer value;

      public put_call(String key, ByteBuffer value, AsyncMethodCallback<put_call> __resultHandler__, TAsyncClient __client__, TProtocolFactory __protocolFactory__, TNonblockingTransport __transport__) throws TException {
        super(__client__, __protocolFactory__, __transport__, __resultHandler__, false);
        this.key = key;
        this.value = value;
      }

      public void write_args(TProtocol __prot__) throws TException {
        __prot__.writeMessageBegin(new TMessage("put", TMessageType.CALL, 0));
        put_args __args__ = new put_args();
        __args__.setKey(key);
        __args__.setValue(value);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      }

      public Response getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol __prot__ = super.client.getProtocolFactory().getProtocol(__memoryTransport__);
        return (new Client(__prot__)).recv_put();
      }
     }
    public void get(String key, AsyncMethodCallback<get_call> __resultHandler__) throws TException {
      checkReady();
      get_call __method_call__ = new get_call(key, __resultHandler__, this, super.protocolFactory, super.transport);
      manager.call(__method_call__);
    }

    public static class get_call extends TAsyncMethodCall {
      private String key;

      public get_call(String key, AsyncMethodCallback<get_call> __resultHandler__, TAsyncClient __client__, TProtocolFactory __protocolFactory__, TNonblockingTransport __transport__) throws TException {
        super(__client__, __protocolFactory__, __transport__, __resultHandler__, false);
        this.key = key;
      }

      public void write_args(TProtocol __prot__) throws TException {
        __prot__.writeMessageBegin(new TMessage("get", TMessageType.CALL, 0));
        get_args __args__ = new get_args();
        __args__.setKey(key);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      }

      public GetResult getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol __prot__ = super.client.getProtocolFactory().getProtocol(__memoryTransport__);
        return (new Client(__prot__)).recv_get();
      }
     }
    public void multipleGet(List<String> keys, AsyncMethodCallback<multipleGet_call> __resultHandler__) throws TException {
      checkReady();
      multipleGet_call __method_call__ = new multipleGet_call(keys, __resultHandler__, this, super.protocolFactory, super.transport);
      manager.call(__method_call__);
    }

    public static class multipleGet_call extends TAsyncMethodCall {
      private List<String> keys;

      public multipleGet_call(List<String> keys, AsyncMethodCallback<multipleGet_call> __resultHandler__, TAsyncClient __client__, TProtocolFactory __protocolFactory__, TNonblockingTransport __transport__) throws TException {
        super(__client__, __protocolFactory__, __transport__, __resultHandler__, false);
        this.keys = keys;
      }

      public void write_args(TProtocol __prot__) throws TException {
        __prot__.writeMessageBegin(new TMessage("multipleGet", TMessageType.CALL, 0));
        multipleGet_args __args__ = new multipleGet_args();
        __args__.setKeys(keys);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      }

      public MultipleGetResult getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol __prot__ = super.client.getProtocolFactory().getProtocol(__memoryTransport__);
        return (new Client(__prot__)).recv_multipleGet();
      }
     }
    public void convertPut(String key, ByteBuffer value, CubeDBFunc classNameOfPut, AsyncMethodCallback<convertPut_call> __resultHandler__) throws TException {
      checkReady();
      convertPut_call __method_call__ = new convertPut_call(key, value, classNameOfPut, __resultHandler__, this, super.protocolFactory, super.transport);
      manager.call(__method_call__);
    }

    public static class convertPut_call extends TAsyncMethodCall {
      private String key;
      private ByteBuffer value;
      private CubeDBFunc classNameOfPut;

      public convertPut_call(String key, ByteBuffer value, CubeDBFunc classNameOfPut, AsyncMethodCallback<convertPut_call> __resultHandler__, TAsyncClient __client__, TProtocolFactory __protocolFactory__, TNonblockingTransport __transport__) throws TException {
        super(__client__, __protocolFactory__, __transport__, __resultHandler__, false);
        this.key = key;
        this.value = value;
        this.classNameOfPut = classNameOfPut;
      }

      public void write_args(TProtocol __prot__) throws TException {
        __prot__.writeMessageBegin(new TMessage("convertPut", TMessageType.CALL, 0));
        convertPut_args __args__ = new convertPut_args();
        __args__.setKey(key);
        __args__.setValue(value);
        __args__.setClassNameOfPut(classNameOfPut);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      }

      public Response getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol __prot__ = super.client.getProtocolFactory().getProtocol(__memoryTransport__);
        return (new Client(__prot__)).recv_convertPut();
      }
     }
    public void convertGet(String key, ByteBuffer inputData, CubeDBFunc classNameOfConvert, AsyncMethodCallback<convertGet_call> __resultHandler__) throws TException {
      checkReady();
      convertGet_call __method_call__ = new convertGet_call(key, inputData, classNameOfConvert, __resultHandler__, this, super.protocolFactory, super.transport);
      manager.call(__method_call__);
    }

    public static class convertGet_call extends TAsyncMethodCall {
      private String key;
      private ByteBuffer inputData;
      private CubeDBFunc classNameOfConvert;

      public convertGet_call(String key, ByteBuffer inputData, CubeDBFunc classNameOfConvert, AsyncMethodCallback<convertGet_call> __resultHandler__, TAsyncClient __client__, TProtocolFactory __protocolFactory__, TNonblockingTransport __transport__) throws TException {
        super(__client__, __protocolFactory__, __transport__, __resultHandler__, false);
        this.key = key;
        this.inputData = inputData;
        this.classNameOfConvert = classNameOfConvert;
      }

      public void write_args(TProtocol __prot__) throws TException {
        __prot__.writeMessageBegin(new TMessage("convertGet", TMessageType.CALL, 0));
        convertGet_args __args__ = new convertGet_args();
        __args__.setKey(key);
        __args__.setInputData(inputData);
        __args__.setClassNameOfConvert(classNameOfConvert);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      }

      public GetResult getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol __prot__ = super.client.getProtocolFactory().getProtocol(__memoryTransport__);
        return (new Client(__prot__)).recv_convertGet();
      }
     }
    public void convertMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, boolean isLocal, AsyncMethodCallback<convertMultipleGet_call> __resultHandler__) throws TException {
      checkReady();
      convertMultipleGet_call __method_call__ = new convertMultipleGet_call(keys, inputData, classNameOfConvert, isLocal, __resultHandler__, this, super.protocolFactory, super.transport);
      manager.call(__method_call__);
    }

    public static class convertMultipleGet_call extends TAsyncMethodCall {
      private List<String> keys;
      private ByteBuffer inputData;
      private CubeDBFunc classNameOfConvert;
      private boolean isLocal;

      public convertMultipleGet_call(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, boolean isLocal, AsyncMethodCallback<convertMultipleGet_call> __resultHandler__, TAsyncClient __client__, TProtocolFactory __protocolFactory__, TNonblockingTransport __transport__) throws TException {
        super(__client__, __protocolFactory__, __transport__, __resultHandler__, false);
        this.keys = keys;
        this.inputData = inputData;
        this.classNameOfConvert = classNameOfConvert;
        this.isLocal = isLocal;
      }

      public void write_args(TProtocol __prot__) throws TException {
        __prot__.writeMessageBegin(new TMessage("convertMultipleGet", TMessageType.CALL, 0));
        convertMultipleGet_args __args__ = new convertMultipleGet_args();
        __args__.setKeys(keys);
        __args__.setInputData(inputData);
        __args__.setClassNameOfConvert(classNameOfConvert);
        __args__.setIsLocal(isLocal);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      }

      public MultipleGetResult getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol __prot__ = super.client.getProtocolFactory().getProtocol(__memoryTransport__);
        return (new Client(__prot__)).recv_convertMultipleGet();
      }
     }
    public void combineMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfCombine, boolean isLocal, AsyncMethodCallback<combineMultipleGet_call> __resultHandler__) throws TException {
      checkReady();
      combineMultipleGet_call __method_call__ = new combineMultipleGet_call(keys, inputData, classNameOfConvert, classNameOfCombine, isLocal, __resultHandler__, this, super.protocolFactory, super.transport);
      manager.call(__method_call__);
    }

    public static class combineMultipleGet_call extends TAsyncMethodCall {
      private List<String> keys;
      private ByteBuffer inputData;
      private CubeDBFunc classNameOfConvert;
      private CubeDBFunc classNameOfCombine;
      private boolean isLocal;

      public combineMultipleGet_call(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfCombine, boolean isLocal, AsyncMethodCallback<combineMultipleGet_call> __resultHandler__, TAsyncClient __client__, TProtocolFactory __protocolFactory__, TNonblockingTransport __transport__) throws TException {
        super(__client__, __protocolFactory__, __transport__, __resultHandler__, false);
        this.keys = keys;
        this.inputData = inputData;
        this.classNameOfConvert = classNameOfConvert;
        this.classNameOfCombine = classNameOfCombine;
        this.isLocal = isLocal;
      }

      public void write_args(TProtocol __prot__) throws TException {
        __prot__.writeMessageBegin(new TMessage("combineMultipleGet", TMessageType.CALL, 0));
        combineMultipleGet_args __args__ = new combineMultipleGet_args();
        __args__.setKeys(keys);
        __args__.setInputData(inputData);
        __args__.setClassNameOfConvert(classNameOfConvert);
        __args__.setClassNameOfCombine(classNameOfCombine);
        __args__.setIsLocal(isLocal);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      }

      public CombineGetResult getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol __prot__ = super.client.getProtocolFactory().getProtocol(__memoryTransport__);
        return (new Client(__prot__)).recv_combineMultipleGet();
      }
     }
    public void combineMultipleFilter(List<String> includeKeys, List<String> excludeKeys, ByteBuffer inputData, CubeDBFunc classNameOfFilter, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfMerge, boolean isLocal, AsyncMethodCallback<combineMultipleFilter_call> __resultHandler__) throws TException {
      checkReady();
      combineMultipleFilter_call __method_call__ = new combineMultipleFilter_call(includeKeys, excludeKeys, inputData, classNameOfFilter, classNameOfConvert, classNameOfMerge, isLocal, __resultHandler__, this, super.protocolFactory, super.transport);
      manager.call(__method_call__);
    }

    public static class combineMultipleFilter_call extends TAsyncMethodCall {
      private List<String> includeKeys;
      private List<String> excludeKeys;
      private ByteBuffer inputData;
      private CubeDBFunc classNameOfFilter;
      private CubeDBFunc classNameOfConvert;
      private CubeDBFunc classNameOfMerge;
      private boolean isLocal;

      public combineMultipleFilter_call(List<String> includeKeys, List<String> excludeKeys, ByteBuffer inputData, CubeDBFunc classNameOfFilter, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfMerge, boolean isLocal, AsyncMethodCallback<combineMultipleFilter_call> __resultHandler__, TAsyncClient __client__, TProtocolFactory __protocolFactory__, TNonblockingTransport __transport__) throws TException {
        super(__client__, __protocolFactory__, __transport__, __resultHandler__, false);
        this.includeKeys = includeKeys;
        this.excludeKeys = excludeKeys;
        this.inputData = inputData;
        this.classNameOfFilter = classNameOfFilter;
        this.classNameOfConvert = classNameOfConvert;
        this.classNameOfMerge = classNameOfMerge;
        this.isLocal = isLocal;
      }

      public void write_args(TProtocol __prot__) throws TException {
        __prot__.writeMessageBegin(new TMessage("combineMultipleFilter", TMessageType.CALL, 0));
        combineMultipleFilter_args __args__ = new combineMultipleFilter_args();
        __args__.setIncludeKeys(includeKeys);
        __args__.setExcludeKeys(excludeKeys);
        __args__.setInputData(inputData);
        __args__.setClassNameOfFilter(classNameOfFilter);
        __args__.setClassNameOfConvert(classNameOfConvert);
        __args__.setClassNameOfMerge(classNameOfMerge);
        __args__.setIsLocal(isLocal);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      }

      public CombineGetResult getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol __prot__ = super.client.getProtocolFactory().getProtocol(__memoryTransport__);
        return (new Client(__prot__)).recv_combineMultipleFilter();
      }
     }
   }


  public static class ServiceToClient implements ServiceIface {
    private final com.twitter.finagle.Service<ThriftClientRequest, byte[]> service;
    private final TProtocolFactory protocolFactory;
    private final scala.PartialFunction<com.twitter.finagle.service.ReqRep,com.twitter.finagle.service.ResponseClass> responseClassifier;

    public ServiceToClient(com.twitter.finagle.Service<ThriftClientRequest, byte[]> service, TProtocolFactory protocolFactory, scala.PartialFunction<com.twitter.finagle.service.ReqRep,com.twitter.finagle.service.ResponseClass> responseClassifier) {
      
      this.service = service;
      this.protocolFactory = protocolFactory;
      this.responseClassifier = responseClassifier;
    }

    public ServiceToClient(com.twitter.finagle.Service<ThriftClientRequest, byte[]> service, TProtocolFactory protocolFactory) {
      
      this.service = service;
      this.protocolFactory = protocolFactory;
      this.responseClassifier = com.twitter.finagle.service.ResponseClassifier.Default();
    }

    public Future<Response> put(String key, ByteBuffer value) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("put", TMessageType.CALL, 0));
        put_args __args__ = new put_args();
        __args__.setKey(key);
        __args__.setValue(value);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();


        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        final ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);

        Function<byte[], com.twitter.util.Try<Response>> replyDeserializer =
          new Function<byte[], com.twitter.util.Try<Response>>() {
            public com.twitter.util.Try<Response> apply(byte[] __buffer__) {
              TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
              TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
              try {
                return new com.twitter.util.Return(((new Client(__prot__)).recv_put()));
              } catch (Exception e) {
                return new com.twitter.util.Throw(e);
              }
            }
          };
        DeserializeCtx serdeCtx = new DeserializeCtx<Response>(__args__, replyDeserializer);

        return com.twitter.finagle.context.Contexts.local().let(
          DeserializeCtx.Key(),
          serdeCtx,
          new com.twitter.util.Function0<Future<Response>>() {
            public Future<Response> apply() {

              Future<byte[]> __done__ = service.apply(__request__);
              return __done__.flatMap(new Function<byte[], Future<Response>>() {
                public Future<Response> apply(byte[] __buffer__) {
                  TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
                  TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
                  try {
                    return Future.value((new Client(__prot__)).recv_put());
                  } catch (Exception e) {
                    return Future.exception(e);
                  }
                }
              });
            }
          });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<GetResult> get(String key) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("get", TMessageType.CALL, 0));
        get_args __args__ = new get_args();
        __args__.setKey(key);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();


        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        final ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);

        Function<byte[], com.twitter.util.Try<GetResult>> replyDeserializer =
          new Function<byte[], com.twitter.util.Try<GetResult>>() {
            public com.twitter.util.Try<GetResult> apply(byte[] __buffer__) {
              TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
              TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
              try {
                return new com.twitter.util.Return(((new Client(__prot__)).recv_get()));
              } catch (Exception e) {
                return new com.twitter.util.Throw(e);
              }
            }
          };
        DeserializeCtx serdeCtx = new DeserializeCtx<GetResult>(__args__, replyDeserializer);

        return com.twitter.finagle.context.Contexts.local().let(
          DeserializeCtx.Key(),
          serdeCtx,
          new com.twitter.util.Function0<Future<GetResult>>() {
            public Future<GetResult> apply() {

              Future<byte[]> __done__ = service.apply(__request__);
              return __done__.flatMap(new Function<byte[], Future<GetResult>>() {
                public Future<GetResult> apply(byte[] __buffer__) {
                  TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
                  TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
                  try {
                    return Future.value((new Client(__prot__)).recv_get());
                  } catch (Exception e) {
                    return Future.exception(e);
                  }
                }
              });
            }
          });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<MultipleGetResult> multipleGet(List<String> keys) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("multipleGet", TMessageType.CALL, 0));
        multipleGet_args __args__ = new multipleGet_args();
        __args__.setKeys(keys);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();


        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        final ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);

        Function<byte[], com.twitter.util.Try<MultipleGetResult>> replyDeserializer =
          new Function<byte[], com.twitter.util.Try<MultipleGetResult>>() {
            public com.twitter.util.Try<MultipleGetResult> apply(byte[] __buffer__) {
              TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
              TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
              try {
                return new com.twitter.util.Return(((new Client(__prot__)).recv_multipleGet()));
              } catch (Exception e) {
                return new com.twitter.util.Throw(e);
              }
            }
          };
        DeserializeCtx serdeCtx = new DeserializeCtx<MultipleGetResult>(__args__, replyDeserializer);

        return com.twitter.finagle.context.Contexts.local().let(
          DeserializeCtx.Key(),
          serdeCtx,
          new com.twitter.util.Function0<Future<MultipleGetResult>>() {
            public Future<MultipleGetResult> apply() {

              Future<byte[]> __done__ = service.apply(__request__);
              return __done__.flatMap(new Function<byte[], Future<MultipleGetResult>>() {
                public Future<MultipleGetResult> apply(byte[] __buffer__) {
                  TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
                  TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
                  try {
                    return Future.value((new Client(__prot__)).recv_multipleGet());
                  } catch (Exception e) {
                    return Future.exception(e);
                  }
                }
              });
            }
          });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Response> convertPut(String key, ByteBuffer value, CubeDBFunc classNameOfPut) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("convertPut", TMessageType.CALL, 0));
        convertPut_args __args__ = new convertPut_args();
        __args__.setKey(key);
        __args__.setValue(value);
        __args__.setClassNameOfPut(classNameOfPut);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();


        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        final ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);

        Function<byte[], com.twitter.util.Try<Response>> replyDeserializer =
          new Function<byte[], com.twitter.util.Try<Response>>() {
            public com.twitter.util.Try<Response> apply(byte[] __buffer__) {
              TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
              TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
              try {
                return new com.twitter.util.Return(((new Client(__prot__)).recv_convertPut()));
              } catch (Exception e) {
                return new com.twitter.util.Throw(e);
              }
            }
          };
        DeserializeCtx serdeCtx = new DeserializeCtx<Response>(__args__, replyDeserializer);

        return com.twitter.finagle.context.Contexts.local().let(
          DeserializeCtx.Key(),
          serdeCtx,
          new com.twitter.util.Function0<Future<Response>>() {
            public Future<Response> apply() {

              Future<byte[]> __done__ = service.apply(__request__);
              return __done__.flatMap(new Function<byte[], Future<Response>>() {
                public Future<Response> apply(byte[] __buffer__) {
                  TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
                  TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
                  try {
                    return Future.value((new Client(__prot__)).recv_convertPut());
                  } catch (Exception e) {
                    return Future.exception(e);
                  }
                }
              });
            }
          });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<GetResult> convertGet(String key, ByteBuffer inputData, CubeDBFunc classNameOfConvert) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("convertGet", TMessageType.CALL, 0));
        convertGet_args __args__ = new convertGet_args();
        __args__.setKey(key);
        __args__.setInputData(inputData);
        __args__.setClassNameOfConvert(classNameOfConvert);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();


        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        final ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);

        Function<byte[], com.twitter.util.Try<GetResult>> replyDeserializer =
          new Function<byte[], com.twitter.util.Try<GetResult>>() {
            public com.twitter.util.Try<GetResult> apply(byte[] __buffer__) {
              TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
              TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
              try {
                return new com.twitter.util.Return(((new Client(__prot__)).recv_convertGet()));
              } catch (Exception e) {
                return new com.twitter.util.Throw(e);
              }
            }
          };
        DeserializeCtx serdeCtx = new DeserializeCtx<GetResult>(__args__, replyDeserializer);

        return com.twitter.finagle.context.Contexts.local().let(
          DeserializeCtx.Key(),
          serdeCtx,
          new com.twitter.util.Function0<Future<GetResult>>() {
            public Future<GetResult> apply() {

              Future<byte[]> __done__ = service.apply(__request__);
              return __done__.flatMap(new Function<byte[], Future<GetResult>>() {
                public Future<GetResult> apply(byte[] __buffer__) {
                  TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
                  TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
                  try {
                    return Future.value((new Client(__prot__)).recv_convertGet());
                  } catch (Exception e) {
                    return Future.exception(e);
                  }
                }
              });
            }
          });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<MultipleGetResult> convertMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, boolean isLocal) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("convertMultipleGet", TMessageType.CALL, 0));
        convertMultipleGet_args __args__ = new convertMultipleGet_args();
        __args__.setKeys(keys);
        __args__.setInputData(inputData);
        __args__.setClassNameOfConvert(classNameOfConvert);
        __args__.setIsLocal(isLocal);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();


        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        final ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);

        Function<byte[], com.twitter.util.Try<MultipleGetResult>> replyDeserializer =
          new Function<byte[], com.twitter.util.Try<MultipleGetResult>>() {
            public com.twitter.util.Try<MultipleGetResult> apply(byte[] __buffer__) {
              TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
              TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
              try {
                return new com.twitter.util.Return(((new Client(__prot__)).recv_convertMultipleGet()));
              } catch (Exception e) {
                return new com.twitter.util.Throw(e);
              }
            }
          };
        DeserializeCtx serdeCtx = new DeserializeCtx<MultipleGetResult>(__args__, replyDeserializer);

        return com.twitter.finagle.context.Contexts.local().let(
          DeserializeCtx.Key(),
          serdeCtx,
          new com.twitter.util.Function0<Future<MultipleGetResult>>() {
            public Future<MultipleGetResult> apply() {

              Future<byte[]> __done__ = service.apply(__request__);
              return __done__.flatMap(new Function<byte[], Future<MultipleGetResult>>() {
                public Future<MultipleGetResult> apply(byte[] __buffer__) {
                  TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
                  TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
                  try {
                    return Future.value((new Client(__prot__)).recv_convertMultipleGet());
                  } catch (Exception e) {
                    return Future.exception(e);
                  }
                }
              });
            }
          });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<CombineGetResult> combineMultipleGet(List<String> keys, ByteBuffer inputData, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfCombine, boolean isLocal) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("combineMultipleGet", TMessageType.CALL, 0));
        combineMultipleGet_args __args__ = new combineMultipleGet_args();
        __args__.setKeys(keys);
        __args__.setInputData(inputData);
        __args__.setClassNameOfConvert(classNameOfConvert);
        __args__.setClassNameOfCombine(classNameOfCombine);
        __args__.setIsLocal(isLocal);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();


        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        final ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);

        Function<byte[], com.twitter.util.Try<CombineGetResult>> replyDeserializer =
          new Function<byte[], com.twitter.util.Try<CombineGetResult>>() {
            public com.twitter.util.Try<CombineGetResult> apply(byte[] __buffer__) {
              TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
              TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
              try {
                return new com.twitter.util.Return(((new Client(__prot__)).recv_combineMultipleGet()));
              } catch (Exception e) {
                return new com.twitter.util.Throw(e);
              }
            }
          };
        DeserializeCtx serdeCtx = new DeserializeCtx<CombineGetResult>(__args__, replyDeserializer);

        return com.twitter.finagle.context.Contexts.local().let(
          DeserializeCtx.Key(),
          serdeCtx,
          new com.twitter.util.Function0<Future<CombineGetResult>>() {
            public Future<CombineGetResult> apply() {

              Future<byte[]> __done__ = service.apply(__request__);
              return __done__.flatMap(new Function<byte[], Future<CombineGetResult>>() {
                public Future<CombineGetResult> apply(byte[] __buffer__) {
                  TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
                  TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
                  try {
                    return Future.value((new Client(__prot__)).recv_combineMultipleGet());
                  } catch (Exception e) {
                    return Future.exception(e);
                  }
                }
              });
            }
          });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<CombineGetResult> combineMultipleFilter(List<String> includeKeys, List<String> excludeKeys, ByteBuffer inputData, CubeDBFunc classNameOfFilter, CubeDBFunc classNameOfConvert, CubeDBFunc classNameOfMerge, boolean isLocal) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("combineMultipleFilter", TMessageType.CALL, 0));
        combineMultipleFilter_args __args__ = new combineMultipleFilter_args();
        __args__.setIncludeKeys(includeKeys);
        __args__.setExcludeKeys(excludeKeys);
        __args__.setInputData(inputData);
        __args__.setClassNameOfFilter(classNameOfFilter);
        __args__.setClassNameOfConvert(classNameOfConvert);
        __args__.setClassNameOfMerge(classNameOfMerge);
        __args__.setIsLocal(isLocal);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();


        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        final ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);

        Function<byte[], com.twitter.util.Try<CombineGetResult>> replyDeserializer =
          new Function<byte[], com.twitter.util.Try<CombineGetResult>>() {
            public com.twitter.util.Try<CombineGetResult> apply(byte[] __buffer__) {
              TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
              TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
              try {
                return new com.twitter.util.Return(((new Client(__prot__)).recv_combineMultipleFilter()));
              } catch (Exception e) {
                return new com.twitter.util.Throw(e);
              }
            }
          };
        DeserializeCtx serdeCtx = new DeserializeCtx<CombineGetResult>(__args__, replyDeserializer);

        return com.twitter.finagle.context.Contexts.local().let(
          DeserializeCtx.Key(),
          serdeCtx,
          new com.twitter.util.Function0<Future<CombineGetResult>>() {
            public Future<CombineGetResult> apply() {

              Future<byte[]> __done__ = service.apply(__request__);
              return __done__.flatMap(new Function<byte[], Future<CombineGetResult>>() {
                public Future<CombineGetResult> apply(byte[] __buffer__) {
                  TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
                  TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
                  try {
                    return Future.value((new Client(__prot__)).recv_combineMultipleFilter());
                  } catch (Exception e) {
                    return Future.exception(e);
                  }
                }
              });
            }
          });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("put", new put());
      processMap_.put("get", new get());
      processMap_.put("multipleGet", new multipleGet());
      processMap_.put("convertPut", new convertPut());
      processMap_.put("convertGet", new convertGet());
      processMap_.put("convertMultipleGet", new convertMultipleGet());
      processMap_.put("combineMultipleGet", new combineMultipleGet());
      processMap_.put("combineMultipleFilter", new combineMultipleFilter());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class put implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        put_args args = new put_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("put", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        put_result result = new put_result();
        result.success = iface_.put(args.key, args.value);
        
        oprot.writeMessageBegin(new TMessage("put", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }
    }
    private class get implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_args args = new get_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_result result = new get_result();
        result.success = iface_.get(args.key);
        
        oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }
    }
    private class multipleGet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        multipleGet_args args = new multipleGet_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("multipleGet", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        multipleGet_result result = new multipleGet_result();
        result.success = iface_.multipleGet(args.keys);
        
        oprot.writeMessageBegin(new TMessage("multipleGet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }
    }
    private class convertPut implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        convertPut_args args = new convertPut_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("convertPut", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        convertPut_result result = new convertPut_result();
        result.success = iface_.convertPut(args.key, args.value, args.classNameOfPut);
        
        oprot.writeMessageBegin(new TMessage("convertPut", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }
    }
    private class convertGet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        convertGet_args args = new convertGet_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("convertGet", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        convertGet_result result = new convertGet_result();
        result.success = iface_.convertGet(args.key, args.inputData, args.classNameOfConvert);
        
        oprot.writeMessageBegin(new TMessage("convertGet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }
    }
    private class convertMultipleGet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        convertMultipleGet_args args = new convertMultipleGet_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("convertMultipleGet", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        convertMultipleGet_result result = new convertMultipleGet_result();
        result.success = iface_.convertMultipleGet(args.keys, args.inputData, args.classNameOfConvert, args.isLocal);
        
        oprot.writeMessageBegin(new TMessage("convertMultipleGet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }
    }
    private class combineMultipleGet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        combineMultipleGet_args args = new combineMultipleGet_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("combineMultipleGet", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        combineMultipleGet_result result = new combineMultipleGet_result();
        result.success = iface_.combineMultipleGet(args.keys, args.inputData, args.classNameOfConvert, args.classNameOfCombine, args.isLocal);
        
        oprot.writeMessageBegin(new TMessage("combineMultipleGet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }
    }
    private class combineMultipleFilter implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        combineMultipleFilter_args args = new combineMultipleFilter_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("combineMultipleFilter", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        combineMultipleFilter_result result = new combineMultipleFilter_result();
        result.success = iface_.combineMultipleFilter(args.includeKeys, args.excludeKeys, args.inputData, args.classNameOfFilter, args.classNameOfConvert, args.classNameOfMerge, args.isLocal);
        
        oprot.writeMessageBegin(new TMessage("combineMultipleFilter", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }
    }
  }

  public static class Service extends com.twitter.finagle.Service<byte[], byte[]> {
    private final ServiceIface iface;
    private final TProtocolFactory protocolFactory;
    protected HashMap<String, Function2<TProtocol, Integer, Future<byte[]>>> functionMap = new HashMap<String, Function2<TProtocol, Integer, Future<byte[]>>>();
    public Service(final ServiceIface iface, final TProtocolFactory protocolFactory) {
      this.iface = iface;
      this.protocolFactory = protocolFactory;
      functionMap.put("put", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          put_args args = new put_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

              oprot.writeMessageBegin(new TMessage("put", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }

          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Response> future;
          try {
            future = iface.put(args.key, args.value);
          } catch (Exception e) {
            future = Future.exception(e);
          }

          try {
            return future.flatMap(new Function<Response, Future<byte[]>>() {
              public Future<byte[]> apply(Response value) {
                put_result result = new put_result();
                result.success = value;
                result.setSuccessIsSet(true);

                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

                  oprot.writeMessageBegin(new TMessage("put", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();

                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      functionMap.put("get", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          get_args args = new get_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

              oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }

          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<GetResult> future;
          try {
            future = iface.get(args.key);
          } catch (Exception e) {
            future = Future.exception(e);
          }

          try {
            return future.flatMap(new Function<GetResult, Future<byte[]>>() {
              public Future<byte[]> apply(GetResult value) {
                get_result result = new get_result();
                result.success = value;
                result.setSuccessIsSet(true);

                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

                  oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();

                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      functionMap.put("multipleGet", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          multipleGet_args args = new multipleGet_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

              oprot.writeMessageBegin(new TMessage("multipleGet", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }

          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<MultipleGetResult> future;
          try {
            future = iface.multipleGet(args.keys);
          } catch (Exception e) {
            future = Future.exception(e);
          }

          try {
            return future.flatMap(new Function<MultipleGetResult, Future<byte[]>>() {
              public Future<byte[]> apply(MultipleGetResult value) {
                multipleGet_result result = new multipleGet_result();
                result.success = value;
                result.setSuccessIsSet(true);

                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

                  oprot.writeMessageBegin(new TMessage("multipleGet", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();

                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      functionMap.put("convertPut", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          convertPut_args args = new convertPut_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

              oprot.writeMessageBegin(new TMessage("convertPut", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }

          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Response> future;
          try {
            future = iface.convertPut(args.key, args.value, args.classNameOfPut);
          } catch (Exception e) {
            future = Future.exception(e);
          }

          try {
            return future.flatMap(new Function<Response, Future<byte[]>>() {
              public Future<byte[]> apply(Response value) {
                convertPut_result result = new convertPut_result();
                result.success = value;
                result.setSuccessIsSet(true);

                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

                  oprot.writeMessageBegin(new TMessage("convertPut", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();

                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      functionMap.put("convertGet", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          convertGet_args args = new convertGet_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

              oprot.writeMessageBegin(new TMessage("convertGet", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }

          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<GetResult> future;
          try {
            future = iface.convertGet(args.key, args.inputData, args.classNameOfConvert);
          } catch (Exception e) {
            future = Future.exception(e);
          }

          try {
            return future.flatMap(new Function<GetResult, Future<byte[]>>() {
              public Future<byte[]> apply(GetResult value) {
                convertGet_result result = new convertGet_result();
                result.success = value;
                result.setSuccessIsSet(true);

                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

                  oprot.writeMessageBegin(new TMessage("convertGet", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();

                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      functionMap.put("convertMultipleGet", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          convertMultipleGet_args args = new convertMultipleGet_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

              oprot.writeMessageBegin(new TMessage("convertMultipleGet", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }

          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<MultipleGetResult> future;
          try {
            future = iface.convertMultipleGet(args.keys, args.inputData, args.classNameOfConvert, args.isLocal);
          } catch (Exception e) {
            future = Future.exception(e);
          }

          try {
            return future.flatMap(new Function<MultipleGetResult, Future<byte[]>>() {
              public Future<byte[]> apply(MultipleGetResult value) {
                convertMultipleGet_result result = new convertMultipleGet_result();
                result.success = value;
                result.setSuccessIsSet(true);

                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

                  oprot.writeMessageBegin(new TMessage("convertMultipleGet", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();

                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      functionMap.put("combineMultipleGet", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          combineMultipleGet_args args = new combineMultipleGet_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

              oprot.writeMessageBegin(new TMessage("combineMultipleGet", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }

          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<CombineGetResult> future;
          try {
            future = iface.combineMultipleGet(args.keys, args.inputData, args.classNameOfConvert, args.classNameOfCombine, args.isLocal);
          } catch (Exception e) {
            future = Future.exception(e);
          }

          try {
            return future.flatMap(new Function<CombineGetResult, Future<byte[]>>() {
              public Future<byte[]> apply(CombineGetResult value) {
                combineMultipleGet_result result = new combineMultipleGet_result();
                result.success = value;
                result.setSuccessIsSet(true);

                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

                  oprot.writeMessageBegin(new TMessage("combineMultipleGet", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();

                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      functionMap.put("combineMultipleFilter", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          combineMultipleFilter_args args = new combineMultipleFilter_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

              oprot.writeMessageBegin(new TMessage("combineMultipleFilter", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }

          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<CombineGetResult> future;
          try {
            future = iface.combineMultipleFilter(args.includeKeys, args.excludeKeys, args.inputData, args.classNameOfFilter, args.classNameOfConvert, args.classNameOfMerge, args.isLocal);
          } catch (Exception e) {
            future = Future.exception(e);
          }

          try {
            return future.flatMap(new Function<CombineGetResult, Future<byte[]>>() {
              public Future<byte[]> apply(CombineGetResult value) {
                combineMultipleFilter_result result = new combineMultipleFilter_result();
                result.success = value;
                result.setSuccessIsSet(true);

                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);

                  oprot.writeMessageBegin(new TMessage("combineMultipleFilter", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();

                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
    }

    public Future<byte[]> apply(byte[] request) {
      TTransport inputTransport = new TMemoryInputTransport(request);
      TProtocol iprot = protocolFactory.getProtocol(inputTransport);

      TMessage msg;
      try {
        msg = iprot.readMessageBegin();
      } catch (Exception e) {
        return Future.exception(e);
      }

      Function2<TProtocol, Integer, Future<byte[]>> fn = functionMap.get(msg.name);
      if (fn == null) {
        try {
          TProtocolUtil.skip(iprot, TType.STRUCT);
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
          TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
          TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
        } catch (Exception e) {
          return Future.exception(e);
        }
      }

      return fn.apply(iprot, msg.seqid);
    }
  }

  public static class put_args implements TBase<put_args, put_args._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("put_args");

  private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
  private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)2);


  public String key;
  public ByteBuffer value;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    KEY((short)1, "key"),
    VALUE((short)2, "value");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // KEY
          return KEY;
        case 2: // VALUE
          return VALUE;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.STRING)));
    tmpMap.put(_Fields.VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.STRING)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(put_args.class, metaDataMap);
  }


  public put_args() {
  }

  public put_args(
    String key,
    ByteBuffer value)
  {
    this();
    this.key = key;
    this.value = value;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public put_args(put_args other) {
    if (other.isSetKey()) {
      this.key = other.key;
    }
    if (other.isSetValue()) {
      this.value = TBaseHelper.copyBinary(other.value);
    }
  }

  public put_args deepCopy() {
    return new put_args(this);
  }

  @java.lang.Override
  public void clear() {
    this.key = null;
    this.value = null;
  }

  public String getKey() {
    return this.key;
  }

  public put_args setKey(String key) {
    this.key = key;
    
    return this;
  }

  public void unsetKey() {
    this.key = null;
  }

  /** Returns true if field key is set (has been asigned a value) and false otherwise */
  public boolean isSetKey() {
    return this.key != null;
  }

  public void setKeyIsSet(boolean value) {
    if (!value) {
      this.key = null;
    }
  }

  public byte[] getValue() {
    setValue(TBaseHelper.rightSize(value));
    return value.array();
  }

  public ByteBuffer BufferForValue() {
    return value;
  }

  public put_args setValue(byte[] value) {
    setValue(ByteBuffer.wrap(value));
    return this;
  }

  public put_args setValue(ByteBuffer value) {
    this.value = value;
    
    return this;
  }

  public void unsetValue() {
    this.value = null;
  }

  /** Returns true if field value is set (has been asigned a value) and false otherwise */
  public boolean isSetValue() {
    return this.value != null;
  }

  public void setValueIsSet(boolean value) {
    if (!value) {
      this.value = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case KEY:
      if (value == null) {
        unsetKey();
      } else {
        setKey((String)value);
      }
      break;
    case VALUE:
      if (value == null) {
        unsetValue();
      } else {
        setValue((ByteBuffer)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case KEY:
      return getKey();
    case VALUE:
      return getValue();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case KEY:
      return isSetKey();
    case VALUE:
      return isSetValue();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof put_args)
      return this.equals((put_args)that);
    return false;
  }

  public boolean equals(put_args that) {
    if (that == null)
      return false;
    boolean this_present_key = true && this.isSetKey();
    boolean that_present_key = true && that.isSetKey();
    if (this_present_key || that_present_key) {
      if (!(this_present_key && that_present_key))
        return false;
      if (!this.key.equals(that.key))
        return false;
    }
    boolean this_present_value = true && this.isSetValue();
    boolean that_present_value = true && that.isSetValue();
    if (this_present_value || that_present_value) {
      if (!(this_present_value && that_present_value))
        return false;
      if (!this.value.equals(that.value))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_key = true && (isSetKey());
    builder.append(present_key);
    if (present_key)
      builder.append(key);
    boolean present_value = true && (isSetValue());
    builder.append(present_value);
    if (present_value)
      builder.append(value);
    return builder.toHashCode();
  }

  public int compareTo(put_args other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    put_args typedOther = (put_args)other;

    lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetKey()) {
      lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetValue()).compareTo(typedOther.isSetValue());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetValue()) {
      lastComparison = TBaseHelper.compareTo(this.value, typedOther.value);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 1: // KEY
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // VALUE
          if (field.type == TType.STRING) {
            this.value = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();
    
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.key != null) {
      oprot.writeFieldBegin(KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    if (this.value != null) {
      oprot.writeFieldBegin(VALUE_FIELD_DESC);
      oprot.writeBinary(this.value);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("put_args(");
    boolean first = true;
    sb.append("key:");
    if (this.key == null) {
      sb.append("null");
    } else {
      sb.append(this.key);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("value:");
    if (this.value == null) {
      sb.append("null");
    } else {
      TBaseHelper.toString(this.value, sb);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}


  public static class put_result implements TBase<put_result, put_result._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("put_result");

  private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);


  public Response success;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    SUCCESS((short)0, "success");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 0: // SUCCESS
          return SUCCESS;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, Response.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(put_result.class, metaDataMap);
  }


  public put_result() {
  }

  public put_result(
    Response success)
  {
    this();
    this.success = success;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public put_result(put_result other) {
    if (other.isSetSuccess()) {
      this.success = new Response(other.success);
    }
  }

  public put_result deepCopy() {
    return new put_result(this);
  }

  @java.lang.Override
  public void clear() {
    this.success = null;
  }

  public Response getSuccess() {
    return this.success;
  }

  public put_result setSuccess(Response success) {
    this.success = success;
    
    return this;
  }

  public void unsetSuccess() {
    this.success = null;
  }

  /** Returns true if field success is set (has been asigned a value) and false otherwise */
  public boolean isSetSuccess() {
    return this.success != null;
  }

  public void setSuccessIsSet(boolean value) {
    if (!value) {
      this.success = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        setSuccess((Response)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case SUCCESS:
      return getSuccess();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case SUCCESS:
      return isSetSuccess();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof put_result)
      return this.equals((put_result)that);
    return false;
  }

  public boolean equals(put_result that) {
    if (that == null)
      return false;
    boolean this_present_success = true && this.isSetSuccess();
    boolean that_present_success = true && that.isSetSuccess();
    if (this_present_success || that_present_success) {
      if (!(this_present_success && that_present_success))
        return false;
      if (!this.success.equals(that.success))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_success = true && (isSetSuccess());
    builder.append(present_success);
    if (present_success)
      builder.append(success);
    return builder.toHashCode();
  }

  public int compareTo(put_result other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    put_result typedOther = (put_result)other;

    lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSuccess()) {
      lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 0: // SUCCESS
          if (field.type == TType.STRUCT) {
            this.success = new Response();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("put_result(");
    boolean first = true;
    sb.append("success:");
    if (this.success == null) {
      sb.append("null");
    } else {
      sb.append(this.success);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}



  public static class get_args implements TBase<get_args, get_args._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("get_args");

  private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);


  public String key;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    KEY((short)1, "key");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // KEY
          return KEY;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.STRING)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
  }


  public get_args() {
  }

  public get_args(
    String key)
  {
    this();
    this.key = key;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public get_args(get_args other) {
    if (other.isSetKey()) {
      this.key = other.key;
    }
  }

  public get_args deepCopy() {
    return new get_args(this);
  }

  @java.lang.Override
  public void clear() {
    this.key = null;
  }

  public String getKey() {
    return this.key;
  }

  public get_args setKey(String key) {
    this.key = key;
    
    return this;
  }

  public void unsetKey() {
    this.key = null;
  }

  /** Returns true if field key is set (has been asigned a value) and false otherwise */
  public boolean isSetKey() {
    return this.key != null;
  }

  public void setKeyIsSet(boolean value) {
    if (!value) {
      this.key = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case KEY:
      if (value == null) {
        unsetKey();
      } else {
        setKey((String)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case KEY:
      return getKey();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case KEY:
      return isSetKey();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof get_args)
      return this.equals((get_args)that);
    return false;
  }

  public boolean equals(get_args that) {
    if (that == null)
      return false;
    boolean this_present_key = true && this.isSetKey();
    boolean that_present_key = true && that.isSetKey();
    if (this_present_key || that_present_key) {
      if (!(this_present_key && that_present_key))
        return false;
      if (!this.key.equals(that.key))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_key = true && (isSetKey());
    builder.append(present_key);
    if (present_key)
      builder.append(key);
    return builder.toHashCode();
  }

  public int compareTo(get_args other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    get_args typedOther = (get_args)other;

    lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetKey()) {
      lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 1: // KEY
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();
    
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.key != null) {
      oprot.writeFieldBegin(KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("get_args(");
    boolean first = true;
    sb.append("key:");
    if (this.key == null) {
      sb.append("null");
    } else {
      sb.append(this.key);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}


  public static class get_result implements TBase<get_result, get_result._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("get_result");

  private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);


  public GetResult success;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    SUCCESS((short)0, "success");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 0: // SUCCESS
          return SUCCESS;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, GetResult.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
  }


  public get_result() {
  }

  public get_result(
    GetResult success)
  {
    this();
    this.success = success;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public get_result(get_result other) {
    if (other.isSetSuccess()) {
      this.success = new GetResult(other.success);
    }
  }

  public get_result deepCopy() {
    return new get_result(this);
  }

  @java.lang.Override
  public void clear() {
    this.success = null;
  }

  public GetResult getSuccess() {
    return this.success;
  }

  public get_result setSuccess(GetResult success) {
    this.success = success;
    
    return this;
  }

  public void unsetSuccess() {
    this.success = null;
  }

  /** Returns true if field success is set (has been asigned a value) and false otherwise */
  public boolean isSetSuccess() {
    return this.success != null;
  }

  public void setSuccessIsSet(boolean value) {
    if (!value) {
      this.success = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        setSuccess((GetResult)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case SUCCESS:
      return getSuccess();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case SUCCESS:
      return isSetSuccess();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof get_result)
      return this.equals((get_result)that);
    return false;
  }

  public boolean equals(get_result that) {
    if (that == null)
      return false;
    boolean this_present_success = true && this.isSetSuccess();
    boolean that_present_success = true && that.isSetSuccess();
    if (this_present_success || that_present_success) {
      if (!(this_present_success && that_present_success))
        return false;
      if (!this.success.equals(that.success))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_success = true && (isSetSuccess());
    builder.append(present_success);
    if (present_success)
      builder.append(success);
    return builder.toHashCode();
  }

  public int compareTo(get_result other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    get_result typedOther = (get_result)other;

    lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSuccess()) {
      lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 0: // SUCCESS
          if (field.type == TType.STRUCT) {
            this.success = new GetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("get_result(");
    boolean first = true;
    sb.append("success:");
    if (this.success == null) {
      sb.append("null");
    } else {
      sb.append(this.success);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}



  public static class multipleGet_args implements TBase<multipleGet_args, multipleGet_args._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("multipleGet_args");

  private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)1);


  public List<String> keys;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    KEYS((short)1, "keys");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // KEYS
          return KEYS;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.KEYS, new FieldMetaData("keys", TFieldRequirementType.DEFAULT,
      new ListMetaData(TType.LIST,
                new FieldValueMetaData(TType.STRING))));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(multipleGet_args.class, metaDataMap);
  }


  public multipleGet_args() {
  }

  public multipleGet_args(
    List<String> keys)
  {
    this();
    this.keys = keys;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public multipleGet_args(multipleGet_args other) {
    if (other.isSetKeys()) {
      List<String> __this__keys = new ArrayList<String>();
      for (String other_element : other.keys) {
        __this__keys.add(other_element);
      }
      this.keys = __this__keys;
    }
  }

  public multipleGet_args deepCopy() {
    return new multipleGet_args(this);
  }

  @java.lang.Override
  public void clear() {
    this.keys = null;
  }

  public int getKeysSize() {
    return (this.keys == null) ? 0 : this.keys.size();
  }

  public java.util.Iterator<String> getKeysIterator() {
    return (this.keys == null) ? null : this.keys.iterator();
  }

  public void addToKeys(String elem) {
    if (this.keys == null) {
      this.keys = new ArrayList<String>();
    }
    this.keys.add(elem);
  }

  public List<String> getKeys() {
    return this.keys;
  }

  public multipleGet_args setKeys(List<String> keys) {
    this.keys = keys;
    
    return this;
  }

  public void unsetKeys() {
    this.keys = null;
  }

  /** Returns true if field keys is set (has been asigned a value) and false otherwise */
  public boolean isSetKeys() {
    return this.keys != null;
  }

  public void setKeysIsSet(boolean value) {
    if (!value) {
      this.keys = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case KEYS:
      if (value == null) {
        unsetKeys();
      } else {
        setKeys((List<String>)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case KEYS:
      return getKeys();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case KEYS:
      return isSetKeys();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof multipleGet_args)
      return this.equals((multipleGet_args)that);
    return false;
  }

  public boolean equals(multipleGet_args that) {
    if (that == null)
      return false;
    boolean this_present_keys = true && this.isSetKeys();
    boolean that_present_keys = true && that.isSetKeys();
    if (this_present_keys || that_present_keys) {
      if (!(this_present_keys && that_present_keys))
        return false;
      if (!this.keys.equals(that.keys))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_keys = true && (isSetKeys());
    builder.append(present_keys);
    if (present_keys)
      builder.append(keys);
    return builder.toHashCode();
  }

  public int compareTo(multipleGet_args other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    multipleGet_args typedOther = (multipleGet_args)other;

    lastComparison = Boolean.valueOf(isSetKeys()).compareTo(typedOther.isSetKeys());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetKeys()) {
      lastComparison = TBaseHelper.compareTo(this.keys, typedOther.keys);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 1: // KEYS
          if (field.type == TType.LIST) {
            {
            TList _list19 = iprot.readListBegin();
            this.keys = new ArrayList<String>(_list19.size);
            for (int _i20 = 0; _i20 < _list19.size; ++_i20)
            {
              String _elem21;
              _elem21 = iprot.readString();
              this.keys.add(_elem21);
            }
            iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();
    
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.keys != null) {
      oprot.writeFieldBegin(KEYS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
        for (String _iter22 : this.keys)
        {
          oprot.writeString(_iter22);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("multipleGet_args(");
    boolean first = true;
    sb.append("keys:");
    if (this.keys == null) {
      sb.append("null");
    } else {
      sb.append(this.keys);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}


  public static class multipleGet_result implements TBase<multipleGet_result, multipleGet_result._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("multipleGet_result");

  private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);


  public MultipleGetResult success;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    SUCCESS((short)0, "success");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 0: // SUCCESS
          return SUCCESS;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, MultipleGetResult.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(multipleGet_result.class, metaDataMap);
  }


  public multipleGet_result() {
  }

  public multipleGet_result(
    MultipleGetResult success)
  {
    this();
    this.success = success;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public multipleGet_result(multipleGet_result other) {
    if (other.isSetSuccess()) {
      this.success = new MultipleGetResult(other.success);
    }
  }

  public multipleGet_result deepCopy() {
    return new multipleGet_result(this);
  }

  @java.lang.Override
  public void clear() {
    this.success = null;
  }

  public MultipleGetResult getSuccess() {
    return this.success;
  }

  public multipleGet_result setSuccess(MultipleGetResult success) {
    this.success = success;
    
    return this;
  }

  public void unsetSuccess() {
    this.success = null;
  }

  /** Returns true if field success is set (has been asigned a value) and false otherwise */
  public boolean isSetSuccess() {
    return this.success != null;
  }

  public void setSuccessIsSet(boolean value) {
    if (!value) {
      this.success = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        setSuccess((MultipleGetResult)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case SUCCESS:
      return getSuccess();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case SUCCESS:
      return isSetSuccess();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof multipleGet_result)
      return this.equals((multipleGet_result)that);
    return false;
  }

  public boolean equals(multipleGet_result that) {
    if (that == null)
      return false;
    boolean this_present_success = true && this.isSetSuccess();
    boolean that_present_success = true && that.isSetSuccess();
    if (this_present_success || that_present_success) {
      if (!(this_present_success && that_present_success))
        return false;
      if (!this.success.equals(that.success))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_success = true && (isSetSuccess());
    builder.append(present_success);
    if (present_success)
      builder.append(success);
    return builder.toHashCode();
  }

  public int compareTo(multipleGet_result other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    multipleGet_result typedOther = (multipleGet_result)other;

    lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSuccess()) {
      lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 0: // SUCCESS
          if (field.type == TType.STRUCT) {
            this.success = new MultipleGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("multipleGet_result(");
    boolean first = true;
    sb.append("success:");
    if (this.success == null) {
      sb.append("null");
    } else {
      sb.append(this.success);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}



  public static class convertPut_args implements TBase<convertPut_args, convertPut_args._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("convertPut_args");

  private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
  private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)2);
  private static final TField CLASS_NAME_OF_PUT_FIELD_DESC = new TField("classNameOfPut", TType.STRUCT, (short)3);


  public String key;
  public ByteBuffer value;
  public CubeDBFunc classNameOfPut;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    KEY((short)1, "key"),
    VALUE((short)2, "value"),
    CLASS_NAME_OF_PUT((short)3, "classNameOfPut");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // KEY
          return KEY;
        case 2: // VALUE
          return VALUE;
        case 3: // CLASS_NAME_OF_PUT
          return CLASS_NAME_OF_PUT;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.STRING)));
    tmpMap.put(_Fields.VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.STRING)));
    tmpMap.put(_Fields.CLASS_NAME_OF_PUT, new FieldMetaData("classNameOfPut", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, CubeDBFunc.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(convertPut_args.class, metaDataMap);
  }


  public convertPut_args() {
  }

  public convertPut_args(
    String key,
    ByteBuffer value,
    CubeDBFunc classNameOfPut)
  {
    this();
    this.key = key;
    this.value = value;
    this.classNameOfPut = classNameOfPut;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public convertPut_args(convertPut_args other) {
    if (other.isSetKey()) {
      this.key = other.key;
    }
    if (other.isSetValue()) {
      this.value = TBaseHelper.copyBinary(other.value);
    }
    if (other.isSetClassNameOfPut()) {
      this.classNameOfPut = new CubeDBFunc(other.classNameOfPut);
    }
  }

  public convertPut_args deepCopy() {
    return new convertPut_args(this);
  }

  @java.lang.Override
  public void clear() {
    this.key = null;
    this.value = null;
    this.classNameOfPut = null;
  }

  public String getKey() {
    return this.key;
  }

  public convertPut_args setKey(String key) {
    this.key = key;
    
    return this;
  }

  public void unsetKey() {
    this.key = null;
  }

  /** Returns true if field key is set (has been asigned a value) and false otherwise */
  public boolean isSetKey() {
    return this.key != null;
  }

  public void setKeyIsSet(boolean value) {
    if (!value) {
      this.key = null;
    }
  }

  public byte[] getValue() {
    setValue(TBaseHelper.rightSize(value));
    return value.array();
  }

  public ByteBuffer BufferForValue() {
    return value;
  }

  public convertPut_args setValue(byte[] value) {
    setValue(ByteBuffer.wrap(value));
    return this;
  }

  public convertPut_args setValue(ByteBuffer value) {
    this.value = value;
    
    return this;
  }

  public void unsetValue() {
    this.value = null;
  }

  /** Returns true if field value is set (has been asigned a value) and false otherwise */
  public boolean isSetValue() {
    return this.value != null;
  }

  public void setValueIsSet(boolean value) {
    if (!value) {
      this.value = null;
    }
  }

  public CubeDBFunc getClassNameOfPut() {
    return this.classNameOfPut;
  }

  public convertPut_args setClassNameOfPut(CubeDBFunc classNameOfPut) {
    this.classNameOfPut = classNameOfPut;
    
    return this;
  }

  public void unsetClassNameOfPut() {
    this.classNameOfPut = null;
  }

  /** Returns true if field classNameOfPut is set (has been asigned a value) and false otherwise */
  public boolean isSetClassNameOfPut() {
    return this.classNameOfPut != null;
  }

  public void setClassNameOfPutIsSet(boolean value) {
    if (!value) {
      this.classNameOfPut = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case KEY:
      if (value == null) {
        unsetKey();
      } else {
        setKey((String)value);
      }
      break;
    case VALUE:
      if (value == null) {
        unsetValue();
      } else {
        setValue((ByteBuffer)value);
      }
      break;
    case CLASS_NAME_OF_PUT:
      if (value == null) {
        unsetClassNameOfPut();
      } else {
        setClassNameOfPut((CubeDBFunc)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case KEY:
      return getKey();
    case VALUE:
      return getValue();
    case CLASS_NAME_OF_PUT:
      return getClassNameOfPut();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case KEY:
      return isSetKey();
    case VALUE:
      return isSetValue();
    case CLASS_NAME_OF_PUT:
      return isSetClassNameOfPut();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof convertPut_args)
      return this.equals((convertPut_args)that);
    return false;
  }

  public boolean equals(convertPut_args that) {
    if (that == null)
      return false;
    boolean this_present_key = true && this.isSetKey();
    boolean that_present_key = true && that.isSetKey();
    if (this_present_key || that_present_key) {
      if (!(this_present_key && that_present_key))
        return false;
      if (!this.key.equals(that.key))
        return false;
    }
    boolean this_present_value = true && this.isSetValue();
    boolean that_present_value = true && that.isSetValue();
    if (this_present_value || that_present_value) {
      if (!(this_present_value && that_present_value))
        return false;
      if (!this.value.equals(that.value))
        return false;
    }
    boolean this_present_classNameOfPut = true && this.isSetClassNameOfPut();
    boolean that_present_classNameOfPut = true && that.isSetClassNameOfPut();
    if (this_present_classNameOfPut || that_present_classNameOfPut) {
      if (!(this_present_classNameOfPut && that_present_classNameOfPut))
        return false;
      if (!this.classNameOfPut.equals(that.classNameOfPut))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_key = true && (isSetKey());
    builder.append(present_key);
    if (present_key)
      builder.append(key);
    boolean present_value = true && (isSetValue());
    builder.append(present_value);
    if (present_value)
      builder.append(value);
    boolean present_classNameOfPut = true && (isSetClassNameOfPut());
    builder.append(present_classNameOfPut);
    if (present_classNameOfPut)
      builder.append(classNameOfPut);
    return builder.toHashCode();
  }

  public int compareTo(convertPut_args other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    convertPut_args typedOther = (convertPut_args)other;

    lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetKey()) {
      lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetValue()).compareTo(typedOther.isSetValue());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetValue()) {
      lastComparison = TBaseHelper.compareTo(this.value, typedOther.value);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClassNameOfPut()).compareTo(typedOther.isSetClassNameOfPut());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClassNameOfPut()) {
      lastComparison = TBaseHelper.compareTo(this.classNameOfPut, typedOther.classNameOfPut);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 1: // KEY
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // VALUE
          if (field.type == TType.STRING) {
            this.value = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 3: // CLASS_NAME_OF_PUT
          if (field.type == TType.STRUCT) {
            this.classNameOfPut = new CubeDBFunc();
            this.classNameOfPut.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();
    
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.key != null) {
      oprot.writeFieldBegin(KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    if (this.value != null) {
      oprot.writeFieldBegin(VALUE_FIELD_DESC);
      oprot.writeBinary(this.value);
      oprot.writeFieldEnd();
    }
    if (this.classNameOfPut != null) {
      oprot.writeFieldBegin(CLASS_NAME_OF_PUT_FIELD_DESC);
      this.classNameOfPut.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("convertPut_args(");
    boolean first = true;
    sb.append("key:");
    if (this.key == null) {
      sb.append("null");
    } else {
      sb.append(this.key);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("value:");
    if (this.value == null) {
      sb.append("null");
    } else {
      TBaseHelper.toString(this.value, sb);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("classNameOfPut:");
    if (this.classNameOfPut == null) {
      sb.append("null");
    } else {
      sb.append(this.classNameOfPut);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}


  public static class convertPut_result implements TBase<convertPut_result, convertPut_result._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("convertPut_result");

  private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);


  public Response success;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    SUCCESS((short)0, "success");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 0: // SUCCESS
          return SUCCESS;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, Response.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(convertPut_result.class, metaDataMap);
  }


  public convertPut_result() {
  }

  public convertPut_result(
    Response success)
  {
    this();
    this.success = success;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public convertPut_result(convertPut_result other) {
    if (other.isSetSuccess()) {
      this.success = new Response(other.success);
    }
  }

  public convertPut_result deepCopy() {
    return new convertPut_result(this);
  }

  @java.lang.Override
  public void clear() {
    this.success = null;
  }

  public Response getSuccess() {
    return this.success;
  }

  public convertPut_result setSuccess(Response success) {
    this.success = success;
    
    return this;
  }

  public void unsetSuccess() {
    this.success = null;
  }

  /** Returns true if field success is set (has been asigned a value) and false otherwise */
  public boolean isSetSuccess() {
    return this.success != null;
  }

  public void setSuccessIsSet(boolean value) {
    if (!value) {
      this.success = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        setSuccess((Response)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case SUCCESS:
      return getSuccess();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case SUCCESS:
      return isSetSuccess();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof convertPut_result)
      return this.equals((convertPut_result)that);
    return false;
  }

  public boolean equals(convertPut_result that) {
    if (that == null)
      return false;
    boolean this_present_success = true && this.isSetSuccess();
    boolean that_present_success = true && that.isSetSuccess();
    if (this_present_success || that_present_success) {
      if (!(this_present_success && that_present_success))
        return false;
      if (!this.success.equals(that.success))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_success = true && (isSetSuccess());
    builder.append(present_success);
    if (present_success)
      builder.append(success);
    return builder.toHashCode();
  }

  public int compareTo(convertPut_result other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    convertPut_result typedOther = (convertPut_result)other;

    lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSuccess()) {
      lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 0: // SUCCESS
          if (field.type == TType.STRUCT) {
            this.success = new Response();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("convertPut_result(");
    boolean first = true;
    sb.append("success:");
    if (this.success == null) {
      sb.append("null");
    } else {
      sb.append(this.success);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}



  public static class convertGet_args implements TBase<convertGet_args, convertGet_args._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("convertGet_args");

  private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
  private static final TField INPUT_DATA_FIELD_DESC = new TField("inputData", TType.STRING, (short)2);
  private static final TField CLASS_NAME_OF_CONVERT_FIELD_DESC = new TField("classNameOfConvert", TType.STRUCT, (short)3);


  public String key;
  public ByteBuffer inputData;
  public CubeDBFunc classNameOfConvert;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    KEY((short)1, "key"),
    INPUT_DATA((short)2, "inputData"),
    CLASS_NAME_OF_CONVERT((short)3, "classNameOfConvert");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // KEY
          return KEY;
        case 2: // INPUT_DATA
          return INPUT_DATA;
        case 3: // CLASS_NAME_OF_CONVERT
          return CLASS_NAME_OF_CONVERT;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.STRING)));
    tmpMap.put(_Fields.INPUT_DATA, new FieldMetaData("inputData", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.STRING)));
    tmpMap.put(_Fields.CLASS_NAME_OF_CONVERT, new FieldMetaData("classNameOfConvert", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, CubeDBFunc.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(convertGet_args.class, metaDataMap);
  }


  public convertGet_args() {
  }

  public convertGet_args(
    String key,
    ByteBuffer inputData,
    CubeDBFunc classNameOfConvert)
  {
    this();
    this.key = key;
    this.inputData = inputData;
    this.classNameOfConvert = classNameOfConvert;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public convertGet_args(convertGet_args other) {
    if (other.isSetKey()) {
      this.key = other.key;
    }
    if (other.isSetInputData()) {
      this.inputData = TBaseHelper.copyBinary(other.inputData);
    }
    if (other.isSetClassNameOfConvert()) {
      this.classNameOfConvert = new CubeDBFunc(other.classNameOfConvert);
    }
  }

  public convertGet_args deepCopy() {
    return new convertGet_args(this);
  }

  @java.lang.Override
  public void clear() {
    this.key = null;
    this.inputData = null;
    this.classNameOfConvert = null;
  }

  public String getKey() {
    return this.key;
  }

  public convertGet_args setKey(String key) {
    this.key = key;
    
    return this;
  }

  public void unsetKey() {
    this.key = null;
  }

  /** Returns true if field key is set (has been asigned a value) and false otherwise */
  public boolean isSetKey() {
    return this.key != null;
  }

  public void setKeyIsSet(boolean value) {
    if (!value) {
      this.key = null;
    }
  }

  public byte[] getInputData() {
    setInputData(TBaseHelper.rightSize(inputData));
    return inputData.array();
  }

  public ByteBuffer BufferForInputData() {
    return inputData;
  }

  public convertGet_args setInputData(byte[] inputData) {
    setInputData(ByteBuffer.wrap(inputData));
    return this;
  }

  public convertGet_args setInputData(ByteBuffer inputData) {
    this.inputData = inputData;
    
    return this;
  }

  public void unsetInputData() {
    this.inputData = null;
  }

  /** Returns true if field inputData is set (has been asigned a value) and false otherwise */
  public boolean isSetInputData() {
    return this.inputData != null;
  }

  public void setInputDataIsSet(boolean value) {
    if (!value) {
      this.inputData = null;
    }
  }

  public CubeDBFunc getClassNameOfConvert() {
    return this.classNameOfConvert;
  }

  public convertGet_args setClassNameOfConvert(CubeDBFunc classNameOfConvert) {
    this.classNameOfConvert = classNameOfConvert;
    
    return this;
  }

  public void unsetClassNameOfConvert() {
    this.classNameOfConvert = null;
  }

  /** Returns true if field classNameOfConvert is set (has been asigned a value) and false otherwise */
  public boolean isSetClassNameOfConvert() {
    return this.classNameOfConvert != null;
  }

  public void setClassNameOfConvertIsSet(boolean value) {
    if (!value) {
      this.classNameOfConvert = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case KEY:
      if (value == null) {
        unsetKey();
      } else {
        setKey((String)value);
      }
      break;
    case INPUT_DATA:
      if (value == null) {
        unsetInputData();
      } else {
        setInputData((ByteBuffer)value);
      }
      break;
    case CLASS_NAME_OF_CONVERT:
      if (value == null) {
        unsetClassNameOfConvert();
      } else {
        setClassNameOfConvert((CubeDBFunc)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case KEY:
      return getKey();
    case INPUT_DATA:
      return getInputData();
    case CLASS_NAME_OF_CONVERT:
      return getClassNameOfConvert();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case KEY:
      return isSetKey();
    case INPUT_DATA:
      return isSetInputData();
    case CLASS_NAME_OF_CONVERT:
      return isSetClassNameOfConvert();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof convertGet_args)
      return this.equals((convertGet_args)that);
    return false;
  }

  public boolean equals(convertGet_args that) {
    if (that == null)
      return false;
    boolean this_present_key = true && this.isSetKey();
    boolean that_present_key = true && that.isSetKey();
    if (this_present_key || that_present_key) {
      if (!(this_present_key && that_present_key))
        return false;
      if (!this.key.equals(that.key))
        return false;
    }
    boolean this_present_inputData = true && this.isSetInputData();
    boolean that_present_inputData = true && that.isSetInputData();
    if (this_present_inputData || that_present_inputData) {
      if (!(this_present_inputData && that_present_inputData))
        return false;
      if (!this.inputData.equals(that.inputData))
        return false;
    }
    boolean this_present_classNameOfConvert = true && this.isSetClassNameOfConvert();
    boolean that_present_classNameOfConvert = true && that.isSetClassNameOfConvert();
    if (this_present_classNameOfConvert || that_present_classNameOfConvert) {
      if (!(this_present_classNameOfConvert && that_present_classNameOfConvert))
        return false;
      if (!this.classNameOfConvert.equals(that.classNameOfConvert))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_key = true && (isSetKey());
    builder.append(present_key);
    if (present_key)
      builder.append(key);
    boolean present_inputData = true && (isSetInputData());
    builder.append(present_inputData);
    if (present_inputData)
      builder.append(inputData);
    boolean present_classNameOfConvert = true && (isSetClassNameOfConvert());
    builder.append(present_classNameOfConvert);
    if (present_classNameOfConvert)
      builder.append(classNameOfConvert);
    return builder.toHashCode();
  }

  public int compareTo(convertGet_args other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    convertGet_args typedOther = (convertGet_args)other;

    lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetKey()) {
      lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetInputData()).compareTo(typedOther.isSetInputData());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetInputData()) {
      lastComparison = TBaseHelper.compareTo(this.inputData, typedOther.inputData);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClassNameOfConvert()).compareTo(typedOther.isSetClassNameOfConvert());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClassNameOfConvert()) {
      lastComparison = TBaseHelper.compareTo(this.classNameOfConvert, typedOther.classNameOfConvert);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 1: // KEY
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // INPUT_DATA
          if (field.type == TType.STRING) {
            this.inputData = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 3: // CLASS_NAME_OF_CONVERT
          if (field.type == TType.STRUCT) {
            this.classNameOfConvert = new CubeDBFunc();
            this.classNameOfConvert.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();
    
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.key != null) {
      oprot.writeFieldBegin(KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    if (this.inputData != null) {
      oprot.writeFieldBegin(INPUT_DATA_FIELD_DESC);
      oprot.writeBinary(this.inputData);
      oprot.writeFieldEnd();
    }
    if (this.classNameOfConvert != null) {
      oprot.writeFieldBegin(CLASS_NAME_OF_CONVERT_FIELD_DESC);
      this.classNameOfConvert.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("convertGet_args(");
    boolean first = true;
    sb.append("key:");
    if (this.key == null) {
      sb.append("null");
    } else {
      sb.append(this.key);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("inputData:");
    if (this.inputData == null) {
      sb.append("null");
    } else {
      TBaseHelper.toString(this.inputData, sb);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("classNameOfConvert:");
    if (this.classNameOfConvert == null) {
      sb.append("null");
    } else {
      sb.append(this.classNameOfConvert);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}


  public static class convertGet_result implements TBase<convertGet_result, convertGet_result._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("convertGet_result");

  private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);


  public GetResult success;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    SUCCESS((short)0, "success");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 0: // SUCCESS
          return SUCCESS;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, GetResult.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(convertGet_result.class, metaDataMap);
  }


  public convertGet_result() {
  }

  public convertGet_result(
    GetResult success)
  {
    this();
    this.success = success;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public convertGet_result(convertGet_result other) {
    if (other.isSetSuccess()) {
      this.success = new GetResult(other.success);
    }
  }

  public convertGet_result deepCopy() {
    return new convertGet_result(this);
  }

  @java.lang.Override
  public void clear() {
    this.success = null;
  }

  public GetResult getSuccess() {
    return this.success;
  }

  public convertGet_result setSuccess(GetResult success) {
    this.success = success;
    
    return this;
  }

  public void unsetSuccess() {
    this.success = null;
  }

  /** Returns true if field success is set (has been asigned a value) and false otherwise */
  public boolean isSetSuccess() {
    return this.success != null;
  }

  public void setSuccessIsSet(boolean value) {
    if (!value) {
      this.success = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        setSuccess((GetResult)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case SUCCESS:
      return getSuccess();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case SUCCESS:
      return isSetSuccess();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof convertGet_result)
      return this.equals((convertGet_result)that);
    return false;
  }

  public boolean equals(convertGet_result that) {
    if (that == null)
      return false;
    boolean this_present_success = true && this.isSetSuccess();
    boolean that_present_success = true && that.isSetSuccess();
    if (this_present_success || that_present_success) {
      if (!(this_present_success && that_present_success))
        return false;
      if (!this.success.equals(that.success))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_success = true && (isSetSuccess());
    builder.append(present_success);
    if (present_success)
      builder.append(success);
    return builder.toHashCode();
  }

  public int compareTo(convertGet_result other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    convertGet_result typedOther = (convertGet_result)other;

    lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSuccess()) {
      lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 0: // SUCCESS
          if (field.type == TType.STRUCT) {
            this.success = new GetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("convertGet_result(");
    boolean first = true;
    sb.append("success:");
    if (this.success == null) {
      sb.append("null");
    } else {
      sb.append(this.success);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}



  public static class convertMultipleGet_args implements TBase<convertMultipleGet_args, convertMultipleGet_args._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("convertMultipleGet_args");

  private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)1);
  private static final TField INPUT_DATA_FIELD_DESC = new TField("inputData", TType.STRING, (short)2);
  private static final TField CLASS_NAME_OF_CONVERT_FIELD_DESC = new TField("classNameOfConvert", TType.STRUCT, (short)3);
  private static final TField IS_LOCAL_FIELD_DESC = new TField("isLocal", TType.BOOL, (short)4);


  public List<String> keys;
  public ByteBuffer inputData;
  public CubeDBFunc classNameOfConvert;
  public boolean isLocal;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    KEYS((short)1, "keys"),
    INPUT_DATA((short)2, "inputData"),
    CLASS_NAME_OF_CONVERT((short)3, "classNameOfConvert"),
    IS_LOCAL((short)4, "isLocal");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // KEYS
          return KEYS;
        case 2: // INPUT_DATA
          return INPUT_DATA;
        case 3: // CLASS_NAME_OF_CONVERT
          return CLASS_NAME_OF_CONVERT;
        case 4: // IS_LOCAL
          return IS_LOCAL;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments
  private static final int __ISLOCAL_ISSET_ID = 0;
  private BitSet __isset_bit_vector = new BitSet(1);

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.KEYS, new FieldMetaData("keys", TFieldRequirementType.DEFAULT,
      new ListMetaData(TType.LIST,
                new FieldValueMetaData(TType.STRING))));
    tmpMap.put(_Fields.INPUT_DATA, new FieldMetaData("inputData", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.STRING)));
    tmpMap.put(_Fields.CLASS_NAME_OF_CONVERT, new FieldMetaData("classNameOfConvert", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, CubeDBFunc.class)));
    tmpMap.put(_Fields.IS_LOCAL, new FieldMetaData("isLocal", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.BOOL)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(convertMultipleGet_args.class, metaDataMap);
  }


  public convertMultipleGet_args() {
  }

  public convertMultipleGet_args(
    List<String> keys,
    ByteBuffer inputData,
    CubeDBFunc classNameOfConvert,
    boolean isLocal)
  {
    this();
    this.keys = keys;
    this.inputData = inputData;
    this.classNameOfConvert = classNameOfConvert;
    this.isLocal = isLocal;
    setIsLocalIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public convertMultipleGet_args(convertMultipleGet_args other) {
    __isset_bit_vector.clear();
    __isset_bit_vector.or(other.__isset_bit_vector);
    if (other.isSetKeys()) {
      List<String> __this__keys = new ArrayList<String>();
      for (String other_element : other.keys) {
        __this__keys.add(other_element);
      }
      this.keys = __this__keys;
    }
    if (other.isSetInputData()) {
      this.inputData = TBaseHelper.copyBinary(other.inputData);
    }
    if (other.isSetClassNameOfConvert()) {
      this.classNameOfConvert = new CubeDBFunc(other.classNameOfConvert);
    }
    this.isLocal = other.isLocal;
  }

  public convertMultipleGet_args deepCopy() {
    return new convertMultipleGet_args(this);
  }

  @java.lang.Override
  public void clear() {
    this.keys = null;
    this.inputData = null;
    this.classNameOfConvert = null;
    setIsLocalIsSet(false);
    this.isLocal = false;
  }

  public int getKeysSize() {
    return (this.keys == null) ? 0 : this.keys.size();
  }

  public java.util.Iterator<String> getKeysIterator() {
    return (this.keys == null) ? null : this.keys.iterator();
  }

  public void addToKeys(String elem) {
    if (this.keys == null) {
      this.keys = new ArrayList<String>();
    }
    this.keys.add(elem);
  }

  public List<String> getKeys() {
    return this.keys;
  }

  public convertMultipleGet_args setKeys(List<String> keys) {
    this.keys = keys;
    
    return this;
  }

  public void unsetKeys() {
    this.keys = null;
  }

  /** Returns true if field keys is set (has been asigned a value) and false otherwise */
  public boolean isSetKeys() {
    return this.keys != null;
  }

  public void setKeysIsSet(boolean value) {
    if (!value) {
      this.keys = null;
    }
  }

  public byte[] getInputData() {
    setInputData(TBaseHelper.rightSize(inputData));
    return inputData.array();
  }

  public ByteBuffer BufferForInputData() {
    return inputData;
  }

  public convertMultipleGet_args setInputData(byte[] inputData) {
    setInputData(ByteBuffer.wrap(inputData));
    return this;
  }

  public convertMultipleGet_args setInputData(ByteBuffer inputData) {
    this.inputData = inputData;
    
    return this;
  }

  public void unsetInputData() {
    this.inputData = null;
  }

  /** Returns true if field inputData is set (has been asigned a value) and false otherwise */
  public boolean isSetInputData() {
    return this.inputData != null;
  }

  public void setInputDataIsSet(boolean value) {
    if (!value) {
      this.inputData = null;
    }
  }

  public CubeDBFunc getClassNameOfConvert() {
    return this.classNameOfConvert;
  }

  public convertMultipleGet_args setClassNameOfConvert(CubeDBFunc classNameOfConvert) {
    this.classNameOfConvert = classNameOfConvert;
    
    return this;
  }

  public void unsetClassNameOfConvert() {
    this.classNameOfConvert = null;
  }

  /** Returns true if field classNameOfConvert is set (has been asigned a value) and false otherwise */
  public boolean isSetClassNameOfConvert() {
    return this.classNameOfConvert != null;
  }

  public void setClassNameOfConvertIsSet(boolean value) {
    if (!value) {
      this.classNameOfConvert = null;
    }
  }

  public boolean isIsLocal() {
    return this.isLocal;
  }

  public convertMultipleGet_args setIsLocal(boolean isLocal) {
    this.isLocal = isLocal;
    setIsLocalIsSet(true);

    return this;
  }

  public void unsetIsLocal() {
  __isset_bit_vector.clear(__ISLOCAL_ISSET_ID);
  }

  /** Returns true if field isLocal is set (has been asigned a value) and false otherwise */
  public boolean isSetIsLocal() {
    return __isset_bit_vector.get(__ISLOCAL_ISSET_ID);
  }

  public void setIsLocalIsSet(boolean value) {
    __isset_bit_vector.set(__ISLOCAL_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case KEYS:
      if (value == null) {
        unsetKeys();
      } else {
        setKeys((List<String>)value);
      }
      break;
    case INPUT_DATA:
      if (value == null) {
        unsetInputData();
      } else {
        setInputData((ByteBuffer)value);
      }
      break;
    case CLASS_NAME_OF_CONVERT:
      if (value == null) {
        unsetClassNameOfConvert();
      } else {
        setClassNameOfConvert((CubeDBFunc)value);
      }
      break;
    case IS_LOCAL:
      if (value == null) {
        unsetIsLocal();
      } else {
        setIsLocal((Boolean)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case KEYS:
      return getKeys();
    case INPUT_DATA:
      return getInputData();
    case CLASS_NAME_OF_CONVERT:
      return getClassNameOfConvert();
    case IS_LOCAL:
      return new Boolean(isIsLocal());
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case KEYS:
      return isSetKeys();
    case INPUT_DATA:
      return isSetInputData();
    case CLASS_NAME_OF_CONVERT:
      return isSetClassNameOfConvert();
    case IS_LOCAL:
      return isSetIsLocal();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof convertMultipleGet_args)
      return this.equals((convertMultipleGet_args)that);
    return false;
  }

  public boolean equals(convertMultipleGet_args that) {
    if (that == null)
      return false;
    boolean this_present_keys = true && this.isSetKeys();
    boolean that_present_keys = true && that.isSetKeys();
    if (this_present_keys || that_present_keys) {
      if (!(this_present_keys && that_present_keys))
        return false;
      if (!this.keys.equals(that.keys))
        return false;
    }
    boolean this_present_inputData = true && this.isSetInputData();
    boolean that_present_inputData = true && that.isSetInputData();
    if (this_present_inputData || that_present_inputData) {
      if (!(this_present_inputData && that_present_inputData))
        return false;
      if (!this.inputData.equals(that.inputData))
        return false;
    }
    boolean this_present_classNameOfConvert = true && this.isSetClassNameOfConvert();
    boolean that_present_classNameOfConvert = true && that.isSetClassNameOfConvert();
    if (this_present_classNameOfConvert || that_present_classNameOfConvert) {
      if (!(this_present_classNameOfConvert && that_present_classNameOfConvert))
        return false;
      if (!this.classNameOfConvert.equals(that.classNameOfConvert))
        return false;
    }
    boolean this_present_isLocal = true;
    boolean that_present_isLocal = true;
    if (this_present_isLocal || that_present_isLocal) {
      if (!(this_present_isLocal && that_present_isLocal))
        return false;
      if (this.isLocal != that.isLocal)
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_keys = true && (isSetKeys());
    builder.append(present_keys);
    if (present_keys)
      builder.append(keys);
    boolean present_inputData = true && (isSetInputData());
    builder.append(present_inputData);
    if (present_inputData)
      builder.append(inputData);
    boolean present_classNameOfConvert = true && (isSetClassNameOfConvert());
    builder.append(present_classNameOfConvert);
    if (present_classNameOfConvert)
      builder.append(classNameOfConvert);
    boolean present_isLocal = true;
    builder.append(present_isLocal);
    if (present_isLocal)
      builder.append(isLocal);
    return builder.toHashCode();
  }

  public int compareTo(convertMultipleGet_args other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    convertMultipleGet_args typedOther = (convertMultipleGet_args)other;

    lastComparison = Boolean.valueOf(isSetKeys()).compareTo(typedOther.isSetKeys());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetKeys()) {
      lastComparison = TBaseHelper.compareTo(this.keys, typedOther.keys);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetInputData()).compareTo(typedOther.isSetInputData());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetInputData()) {
      lastComparison = TBaseHelper.compareTo(this.inputData, typedOther.inputData);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClassNameOfConvert()).compareTo(typedOther.isSetClassNameOfConvert());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClassNameOfConvert()) {
      lastComparison = TBaseHelper.compareTo(this.classNameOfConvert, typedOther.classNameOfConvert);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetIsLocal()).compareTo(typedOther.isSetIsLocal());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetIsLocal()) {
      lastComparison = TBaseHelper.compareTo(this.isLocal, typedOther.isLocal);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 1: // KEYS
          if (field.type == TType.LIST) {
            {
            TList _list23 = iprot.readListBegin();
            this.keys = new ArrayList<String>(_list23.size);
            for (int _i24 = 0; _i24 < _list23.size; ++_i24)
            {
              String _elem25;
              _elem25 = iprot.readString();
              this.keys.add(_elem25);
            }
            iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // INPUT_DATA
          if (field.type == TType.STRING) {
            this.inputData = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 3: // CLASS_NAME_OF_CONVERT
          if (field.type == TType.STRUCT) {
            this.classNameOfConvert = new CubeDBFunc();
            this.classNameOfConvert.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 4: // IS_LOCAL
          if (field.type == TType.BOOL) {
            this.isLocal = iprot.readBool();
            setIsLocalIsSet(true);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();
    
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.keys != null) {
      oprot.writeFieldBegin(KEYS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
        for (String _iter26 : this.keys)
        {
          oprot.writeString(_iter26);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.inputData != null) {
      oprot.writeFieldBegin(INPUT_DATA_FIELD_DESC);
      oprot.writeBinary(this.inputData);
      oprot.writeFieldEnd();
    }
    if (this.classNameOfConvert != null) {
      oprot.writeFieldBegin(CLASS_NAME_OF_CONVERT_FIELD_DESC);
      this.classNameOfConvert.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(IS_LOCAL_FIELD_DESC);
    oprot.writeBool(this.isLocal);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("convertMultipleGet_args(");
    boolean first = true;
    sb.append("keys:");
    if (this.keys == null) {
      sb.append("null");
    } else {
      sb.append(this.keys);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("inputData:");
    if (this.inputData == null) {
      sb.append("null");
    } else {
      TBaseHelper.toString(this.inputData, sb);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("classNameOfConvert:");
    if (this.classNameOfConvert == null) {
      sb.append("null");
    } else {
      sb.append(this.classNameOfConvert);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("isLocal:");
    sb.append(this.isLocal);
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}


  public static class convertMultipleGet_result implements TBase<convertMultipleGet_result, convertMultipleGet_result._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("convertMultipleGet_result");

  private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);


  public MultipleGetResult success;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    SUCCESS((short)0, "success");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 0: // SUCCESS
          return SUCCESS;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, MultipleGetResult.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(convertMultipleGet_result.class, metaDataMap);
  }


  public convertMultipleGet_result() {
  }

  public convertMultipleGet_result(
    MultipleGetResult success)
  {
    this();
    this.success = success;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public convertMultipleGet_result(convertMultipleGet_result other) {
    if (other.isSetSuccess()) {
      this.success = new MultipleGetResult(other.success);
    }
  }

  public convertMultipleGet_result deepCopy() {
    return new convertMultipleGet_result(this);
  }

  @java.lang.Override
  public void clear() {
    this.success = null;
  }

  public MultipleGetResult getSuccess() {
    return this.success;
  }

  public convertMultipleGet_result setSuccess(MultipleGetResult success) {
    this.success = success;
    
    return this;
  }

  public void unsetSuccess() {
    this.success = null;
  }

  /** Returns true if field success is set (has been asigned a value) and false otherwise */
  public boolean isSetSuccess() {
    return this.success != null;
  }

  public void setSuccessIsSet(boolean value) {
    if (!value) {
      this.success = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        setSuccess((MultipleGetResult)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case SUCCESS:
      return getSuccess();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case SUCCESS:
      return isSetSuccess();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof convertMultipleGet_result)
      return this.equals((convertMultipleGet_result)that);
    return false;
  }

  public boolean equals(convertMultipleGet_result that) {
    if (that == null)
      return false;
    boolean this_present_success = true && this.isSetSuccess();
    boolean that_present_success = true && that.isSetSuccess();
    if (this_present_success || that_present_success) {
      if (!(this_present_success && that_present_success))
        return false;
      if (!this.success.equals(that.success))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_success = true && (isSetSuccess());
    builder.append(present_success);
    if (present_success)
      builder.append(success);
    return builder.toHashCode();
  }

  public int compareTo(convertMultipleGet_result other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    convertMultipleGet_result typedOther = (convertMultipleGet_result)other;

    lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSuccess()) {
      lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 0: // SUCCESS
          if (field.type == TType.STRUCT) {
            this.success = new MultipleGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("convertMultipleGet_result(");
    boolean first = true;
    sb.append("success:");
    if (this.success == null) {
      sb.append("null");
    } else {
      sb.append(this.success);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}



  public static class combineMultipleGet_args implements TBase<combineMultipleGet_args, combineMultipleGet_args._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("combineMultipleGet_args");

  private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)1);
  private static final TField INPUT_DATA_FIELD_DESC = new TField("inputData", TType.STRING, (short)2);
  private static final TField CLASS_NAME_OF_CONVERT_FIELD_DESC = new TField("classNameOfConvert", TType.STRUCT, (short)3);
  private static final TField CLASS_NAME_OF_COMBINE_FIELD_DESC = new TField("classNameOfCombine", TType.STRUCT, (short)4);
  private static final TField IS_LOCAL_FIELD_DESC = new TField("isLocal", TType.BOOL, (short)5);


  public List<String> keys;
  public ByteBuffer inputData;
  public CubeDBFunc classNameOfConvert;
  public CubeDBFunc classNameOfCombine;
  public boolean isLocal;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    KEYS((short)1, "keys"),
    INPUT_DATA((short)2, "inputData"),
    CLASS_NAME_OF_CONVERT((short)3, "classNameOfConvert"),
    CLASS_NAME_OF_COMBINE((short)4, "classNameOfCombine"),
    IS_LOCAL((short)5, "isLocal");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // KEYS
          return KEYS;
        case 2: // INPUT_DATA
          return INPUT_DATA;
        case 3: // CLASS_NAME_OF_CONVERT
          return CLASS_NAME_OF_CONVERT;
        case 4: // CLASS_NAME_OF_COMBINE
          return CLASS_NAME_OF_COMBINE;
        case 5: // IS_LOCAL
          return IS_LOCAL;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments
  private static final int __ISLOCAL_ISSET_ID = 0;
  private BitSet __isset_bit_vector = new BitSet(1);

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.KEYS, new FieldMetaData("keys", TFieldRequirementType.DEFAULT,
      new ListMetaData(TType.LIST,
                new FieldValueMetaData(TType.STRING))));
    tmpMap.put(_Fields.INPUT_DATA, new FieldMetaData("inputData", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.STRING)));
    tmpMap.put(_Fields.CLASS_NAME_OF_CONVERT, new FieldMetaData("classNameOfConvert", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, CubeDBFunc.class)));
    tmpMap.put(_Fields.CLASS_NAME_OF_COMBINE, new FieldMetaData("classNameOfCombine", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, CubeDBFunc.class)));
    tmpMap.put(_Fields.IS_LOCAL, new FieldMetaData("isLocal", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.BOOL)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(combineMultipleGet_args.class, metaDataMap);
  }


  public combineMultipleGet_args() {
  }

  public combineMultipleGet_args(
    List<String> keys,
    ByteBuffer inputData,
    CubeDBFunc classNameOfConvert,
    CubeDBFunc classNameOfCombine,
    boolean isLocal)
  {
    this();
    this.keys = keys;
    this.inputData = inputData;
    this.classNameOfConvert = classNameOfConvert;
    this.classNameOfCombine = classNameOfCombine;
    this.isLocal = isLocal;
    setIsLocalIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public combineMultipleGet_args(combineMultipleGet_args other) {
    __isset_bit_vector.clear();
    __isset_bit_vector.or(other.__isset_bit_vector);
    if (other.isSetKeys()) {
      List<String> __this__keys = new ArrayList<String>();
      for (String other_element : other.keys) {
        __this__keys.add(other_element);
      }
      this.keys = __this__keys;
    }
    if (other.isSetInputData()) {
      this.inputData = TBaseHelper.copyBinary(other.inputData);
    }
    if (other.isSetClassNameOfConvert()) {
      this.classNameOfConvert = new CubeDBFunc(other.classNameOfConvert);
    }
    if (other.isSetClassNameOfCombine()) {
      this.classNameOfCombine = new CubeDBFunc(other.classNameOfCombine);
    }
    this.isLocal = other.isLocal;
  }

  public combineMultipleGet_args deepCopy() {
    return new combineMultipleGet_args(this);
  }

  @java.lang.Override
  public void clear() {
    this.keys = null;
    this.inputData = null;
    this.classNameOfConvert = null;
    this.classNameOfCombine = null;
    setIsLocalIsSet(false);
    this.isLocal = false;
  }

  public int getKeysSize() {
    return (this.keys == null) ? 0 : this.keys.size();
  }

  public java.util.Iterator<String> getKeysIterator() {
    return (this.keys == null) ? null : this.keys.iterator();
  }

  public void addToKeys(String elem) {
    if (this.keys == null) {
      this.keys = new ArrayList<String>();
    }
    this.keys.add(elem);
  }

  public List<String> getKeys() {
    return this.keys;
  }

  public combineMultipleGet_args setKeys(List<String> keys) {
    this.keys = keys;
    
    return this;
  }

  public void unsetKeys() {
    this.keys = null;
  }

  /** Returns true if field keys is set (has been asigned a value) and false otherwise */
  public boolean isSetKeys() {
    return this.keys != null;
  }

  public void setKeysIsSet(boolean value) {
    if (!value) {
      this.keys = null;
    }
  }

  public byte[] getInputData() {
    setInputData(TBaseHelper.rightSize(inputData));
    return inputData.array();
  }

  public ByteBuffer BufferForInputData() {
    return inputData;
  }

  public combineMultipleGet_args setInputData(byte[] inputData) {
    setInputData(ByteBuffer.wrap(inputData));
    return this;
  }

  public combineMultipleGet_args setInputData(ByteBuffer inputData) {
    this.inputData = inputData;
    
    return this;
  }

  public void unsetInputData() {
    this.inputData = null;
  }

  /** Returns true if field inputData is set (has been asigned a value) and false otherwise */
  public boolean isSetInputData() {
    return this.inputData != null;
  }

  public void setInputDataIsSet(boolean value) {
    if (!value) {
      this.inputData = null;
    }
  }

  public CubeDBFunc getClassNameOfConvert() {
    return this.classNameOfConvert;
  }

  public combineMultipleGet_args setClassNameOfConvert(CubeDBFunc classNameOfConvert) {
    this.classNameOfConvert = classNameOfConvert;
    
    return this;
  }

  public void unsetClassNameOfConvert() {
    this.classNameOfConvert = null;
  }

  /** Returns true if field classNameOfConvert is set (has been asigned a value) and false otherwise */
  public boolean isSetClassNameOfConvert() {
    return this.classNameOfConvert != null;
  }

  public void setClassNameOfConvertIsSet(boolean value) {
    if (!value) {
      this.classNameOfConvert = null;
    }
  }

  public CubeDBFunc getClassNameOfCombine() {
    return this.classNameOfCombine;
  }

  public combineMultipleGet_args setClassNameOfCombine(CubeDBFunc classNameOfCombine) {
    this.classNameOfCombine = classNameOfCombine;
    
    return this;
  }

  public void unsetClassNameOfCombine() {
    this.classNameOfCombine = null;
  }

  /** Returns true if field classNameOfCombine is set (has been asigned a value) and false otherwise */
  public boolean isSetClassNameOfCombine() {
    return this.classNameOfCombine != null;
  }

  public void setClassNameOfCombineIsSet(boolean value) {
    if (!value) {
      this.classNameOfCombine = null;
    }
  }

  public boolean isIsLocal() {
    return this.isLocal;
  }

  public combineMultipleGet_args setIsLocal(boolean isLocal) {
    this.isLocal = isLocal;
    setIsLocalIsSet(true);

    return this;
  }

  public void unsetIsLocal() {
  __isset_bit_vector.clear(__ISLOCAL_ISSET_ID);
  }

  /** Returns true if field isLocal is set (has been asigned a value) and false otherwise */
  public boolean isSetIsLocal() {
    return __isset_bit_vector.get(__ISLOCAL_ISSET_ID);
  }

  public void setIsLocalIsSet(boolean value) {
    __isset_bit_vector.set(__ISLOCAL_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case KEYS:
      if (value == null) {
        unsetKeys();
      } else {
        setKeys((List<String>)value);
      }
      break;
    case INPUT_DATA:
      if (value == null) {
        unsetInputData();
      } else {
        setInputData((ByteBuffer)value);
      }
      break;
    case CLASS_NAME_OF_CONVERT:
      if (value == null) {
        unsetClassNameOfConvert();
      } else {
        setClassNameOfConvert((CubeDBFunc)value);
      }
      break;
    case CLASS_NAME_OF_COMBINE:
      if (value == null) {
        unsetClassNameOfCombine();
      } else {
        setClassNameOfCombine((CubeDBFunc)value);
      }
      break;
    case IS_LOCAL:
      if (value == null) {
        unsetIsLocal();
      } else {
        setIsLocal((Boolean)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case KEYS:
      return getKeys();
    case INPUT_DATA:
      return getInputData();
    case CLASS_NAME_OF_CONVERT:
      return getClassNameOfConvert();
    case CLASS_NAME_OF_COMBINE:
      return getClassNameOfCombine();
    case IS_LOCAL:
      return new Boolean(isIsLocal());
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case KEYS:
      return isSetKeys();
    case INPUT_DATA:
      return isSetInputData();
    case CLASS_NAME_OF_CONVERT:
      return isSetClassNameOfConvert();
    case CLASS_NAME_OF_COMBINE:
      return isSetClassNameOfCombine();
    case IS_LOCAL:
      return isSetIsLocal();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof combineMultipleGet_args)
      return this.equals((combineMultipleGet_args)that);
    return false;
  }

  public boolean equals(combineMultipleGet_args that) {
    if (that == null)
      return false;
    boolean this_present_keys = true && this.isSetKeys();
    boolean that_present_keys = true && that.isSetKeys();
    if (this_present_keys || that_present_keys) {
      if (!(this_present_keys && that_present_keys))
        return false;
      if (!this.keys.equals(that.keys))
        return false;
    }
    boolean this_present_inputData = true && this.isSetInputData();
    boolean that_present_inputData = true && that.isSetInputData();
    if (this_present_inputData || that_present_inputData) {
      if (!(this_present_inputData && that_present_inputData))
        return false;
      if (!this.inputData.equals(that.inputData))
        return false;
    }
    boolean this_present_classNameOfConvert = true && this.isSetClassNameOfConvert();
    boolean that_present_classNameOfConvert = true && that.isSetClassNameOfConvert();
    if (this_present_classNameOfConvert || that_present_classNameOfConvert) {
      if (!(this_present_classNameOfConvert && that_present_classNameOfConvert))
        return false;
      if (!this.classNameOfConvert.equals(that.classNameOfConvert))
        return false;
    }
    boolean this_present_classNameOfCombine = true && this.isSetClassNameOfCombine();
    boolean that_present_classNameOfCombine = true && that.isSetClassNameOfCombine();
    if (this_present_classNameOfCombine || that_present_classNameOfCombine) {
      if (!(this_present_classNameOfCombine && that_present_classNameOfCombine))
        return false;
      if (!this.classNameOfCombine.equals(that.classNameOfCombine))
        return false;
    }
    boolean this_present_isLocal = true;
    boolean that_present_isLocal = true;
    if (this_present_isLocal || that_present_isLocal) {
      if (!(this_present_isLocal && that_present_isLocal))
        return false;
      if (this.isLocal != that.isLocal)
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_keys = true && (isSetKeys());
    builder.append(present_keys);
    if (present_keys)
      builder.append(keys);
    boolean present_inputData = true && (isSetInputData());
    builder.append(present_inputData);
    if (present_inputData)
      builder.append(inputData);
    boolean present_classNameOfConvert = true && (isSetClassNameOfConvert());
    builder.append(present_classNameOfConvert);
    if (present_classNameOfConvert)
      builder.append(classNameOfConvert);
    boolean present_classNameOfCombine = true && (isSetClassNameOfCombine());
    builder.append(present_classNameOfCombine);
    if (present_classNameOfCombine)
      builder.append(classNameOfCombine);
    boolean present_isLocal = true;
    builder.append(present_isLocal);
    if (present_isLocal)
      builder.append(isLocal);
    return builder.toHashCode();
  }

  public int compareTo(combineMultipleGet_args other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    combineMultipleGet_args typedOther = (combineMultipleGet_args)other;

    lastComparison = Boolean.valueOf(isSetKeys()).compareTo(typedOther.isSetKeys());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetKeys()) {
      lastComparison = TBaseHelper.compareTo(this.keys, typedOther.keys);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetInputData()).compareTo(typedOther.isSetInputData());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetInputData()) {
      lastComparison = TBaseHelper.compareTo(this.inputData, typedOther.inputData);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClassNameOfConvert()).compareTo(typedOther.isSetClassNameOfConvert());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClassNameOfConvert()) {
      lastComparison = TBaseHelper.compareTo(this.classNameOfConvert, typedOther.classNameOfConvert);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClassNameOfCombine()).compareTo(typedOther.isSetClassNameOfCombine());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClassNameOfCombine()) {
      lastComparison = TBaseHelper.compareTo(this.classNameOfCombine, typedOther.classNameOfCombine);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetIsLocal()).compareTo(typedOther.isSetIsLocal());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetIsLocal()) {
      lastComparison = TBaseHelper.compareTo(this.isLocal, typedOther.isLocal);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 1: // KEYS
          if (field.type == TType.LIST) {
            {
            TList _list27 = iprot.readListBegin();
            this.keys = new ArrayList<String>(_list27.size);
            for (int _i28 = 0; _i28 < _list27.size; ++_i28)
            {
              String _elem29;
              _elem29 = iprot.readString();
              this.keys.add(_elem29);
            }
            iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // INPUT_DATA
          if (field.type == TType.STRING) {
            this.inputData = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 3: // CLASS_NAME_OF_CONVERT
          if (field.type == TType.STRUCT) {
            this.classNameOfConvert = new CubeDBFunc();
            this.classNameOfConvert.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 4: // CLASS_NAME_OF_COMBINE
          if (field.type == TType.STRUCT) {
            this.classNameOfCombine = new CubeDBFunc();
            this.classNameOfCombine.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 5: // IS_LOCAL
          if (field.type == TType.BOOL) {
            this.isLocal = iprot.readBool();
            setIsLocalIsSet(true);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();
    
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.keys != null) {
      oprot.writeFieldBegin(KEYS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
        for (String _iter30 : this.keys)
        {
          oprot.writeString(_iter30);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.inputData != null) {
      oprot.writeFieldBegin(INPUT_DATA_FIELD_DESC);
      oprot.writeBinary(this.inputData);
      oprot.writeFieldEnd();
    }
    if (this.classNameOfConvert != null) {
      oprot.writeFieldBegin(CLASS_NAME_OF_CONVERT_FIELD_DESC);
      this.classNameOfConvert.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.classNameOfCombine != null) {
      oprot.writeFieldBegin(CLASS_NAME_OF_COMBINE_FIELD_DESC);
      this.classNameOfCombine.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(IS_LOCAL_FIELD_DESC);
    oprot.writeBool(this.isLocal);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("combineMultipleGet_args(");
    boolean first = true;
    sb.append("keys:");
    if (this.keys == null) {
      sb.append("null");
    } else {
      sb.append(this.keys);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("inputData:");
    if (this.inputData == null) {
      sb.append("null");
    } else {
      TBaseHelper.toString(this.inputData, sb);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("classNameOfConvert:");
    if (this.classNameOfConvert == null) {
      sb.append("null");
    } else {
      sb.append(this.classNameOfConvert);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("classNameOfCombine:");
    if (this.classNameOfCombine == null) {
      sb.append("null");
    } else {
      sb.append(this.classNameOfCombine);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("isLocal:");
    sb.append(this.isLocal);
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}


  public static class combineMultipleGet_result implements TBase<combineMultipleGet_result, combineMultipleGet_result._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("combineMultipleGet_result");

  private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);


  public CombineGetResult success;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    SUCCESS((short)0, "success");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 0: // SUCCESS
          return SUCCESS;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, CombineGetResult.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(combineMultipleGet_result.class, metaDataMap);
  }


  public combineMultipleGet_result() {
  }

  public combineMultipleGet_result(
    CombineGetResult success)
  {
    this();
    this.success = success;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public combineMultipleGet_result(combineMultipleGet_result other) {
    if (other.isSetSuccess()) {
      this.success = new CombineGetResult(other.success);
    }
  }

  public combineMultipleGet_result deepCopy() {
    return new combineMultipleGet_result(this);
  }

  @java.lang.Override
  public void clear() {
    this.success = null;
  }

  public CombineGetResult getSuccess() {
    return this.success;
  }

  public combineMultipleGet_result setSuccess(CombineGetResult success) {
    this.success = success;
    
    return this;
  }

  public void unsetSuccess() {
    this.success = null;
  }

  /** Returns true if field success is set (has been asigned a value) and false otherwise */
  public boolean isSetSuccess() {
    return this.success != null;
  }

  public void setSuccessIsSet(boolean value) {
    if (!value) {
      this.success = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        setSuccess((CombineGetResult)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case SUCCESS:
      return getSuccess();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case SUCCESS:
      return isSetSuccess();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof combineMultipleGet_result)
      return this.equals((combineMultipleGet_result)that);
    return false;
  }

  public boolean equals(combineMultipleGet_result that) {
    if (that == null)
      return false;
    boolean this_present_success = true && this.isSetSuccess();
    boolean that_present_success = true && that.isSetSuccess();
    if (this_present_success || that_present_success) {
      if (!(this_present_success && that_present_success))
        return false;
      if (!this.success.equals(that.success))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_success = true && (isSetSuccess());
    builder.append(present_success);
    if (present_success)
      builder.append(success);
    return builder.toHashCode();
  }

  public int compareTo(combineMultipleGet_result other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    combineMultipleGet_result typedOther = (combineMultipleGet_result)other;

    lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSuccess()) {
      lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 0: // SUCCESS
          if (field.type == TType.STRUCT) {
            this.success = new CombineGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("combineMultipleGet_result(");
    boolean first = true;
    sb.append("success:");
    if (this.success == null) {
      sb.append("null");
    } else {
      sb.append(this.success);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}



  public static class combineMultipleFilter_args implements TBase<combineMultipleFilter_args, combineMultipleFilter_args._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("combineMultipleFilter_args");

  private static final TField INCLUDE_KEYS_FIELD_DESC = new TField("includeKeys", TType.LIST, (short)1);
  private static final TField EXCLUDE_KEYS_FIELD_DESC = new TField("excludeKeys", TType.LIST, (short)2);
  private static final TField INPUT_DATA_FIELD_DESC = new TField("inputData", TType.STRING, (short)3);
  private static final TField CLASS_NAME_OF_FILTER_FIELD_DESC = new TField("classNameOfFilter", TType.STRUCT, (short)4);
  private static final TField CLASS_NAME_OF_CONVERT_FIELD_DESC = new TField("classNameOfConvert", TType.STRUCT, (short)5);
  private static final TField CLASS_NAME_OF_MERGE_FIELD_DESC = new TField("classNameOfMerge", TType.STRUCT, (short)6);
  private static final TField IS_LOCAL_FIELD_DESC = new TField("isLocal", TType.BOOL, (short)7);


  public List<String> includeKeys;
  public List<String> excludeKeys;
  public ByteBuffer inputData;
  public CubeDBFunc classNameOfFilter;
  public CubeDBFunc classNameOfConvert;
  public CubeDBFunc classNameOfMerge;
  public boolean isLocal;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    INCLUDE_KEYS((short)1, "includeKeys"),
    EXCLUDE_KEYS((short)2, "excludeKeys"),
    INPUT_DATA((short)3, "inputData"),
    CLASS_NAME_OF_FILTER((short)4, "classNameOfFilter"),
    CLASS_NAME_OF_CONVERT((short)5, "classNameOfConvert"),
    CLASS_NAME_OF_MERGE((short)6, "classNameOfMerge"),
    IS_LOCAL((short)7, "isLocal");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // INCLUDE_KEYS
          return INCLUDE_KEYS;
        case 2: // EXCLUDE_KEYS
          return EXCLUDE_KEYS;
        case 3: // INPUT_DATA
          return INPUT_DATA;
        case 4: // CLASS_NAME_OF_FILTER
          return CLASS_NAME_OF_FILTER;
        case 5: // CLASS_NAME_OF_CONVERT
          return CLASS_NAME_OF_CONVERT;
        case 6: // CLASS_NAME_OF_MERGE
          return CLASS_NAME_OF_MERGE;
        case 7: // IS_LOCAL
          return IS_LOCAL;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments
  private static final int __ISLOCAL_ISSET_ID = 0;
  private BitSet __isset_bit_vector = new BitSet(1);

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.INCLUDE_KEYS, new FieldMetaData("includeKeys", TFieldRequirementType.DEFAULT,
      new ListMetaData(TType.LIST,
                new FieldValueMetaData(TType.STRING))));
    tmpMap.put(_Fields.EXCLUDE_KEYS, new FieldMetaData("excludeKeys", TFieldRequirementType.DEFAULT,
      new ListMetaData(TType.LIST,
                new FieldValueMetaData(TType.STRING))));
    tmpMap.put(_Fields.INPUT_DATA, new FieldMetaData("inputData", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.STRING)));
    tmpMap.put(_Fields.CLASS_NAME_OF_FILTER, new FieldMetaData("classNameOfFilter", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, CubeDBFunc.class)));
    tmpMap.put(_Fields.CLASS_NAME_OF_CONVERT, new FieldMetaData("classNameOfConvert", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, CubeDBFunc.class)));
    tmpMap.put(_Fields.CLASS_NAME_OF_MERGE, new FieldMetaData("classNameOfMerge", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, CubeDBFunc.class)));
    tmpMap.put(_Fields.IS_LOCAL, new FieldMetaData("isLocal", TFieldRequirementType.DEFAULT,
      new FieldValueMetaData(TType.BOOL)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(combineMultipleFilter_args.class, metaDataMap);
  }


  public combineMultipleFilter_args() {
  }

  public combineMultipleFilter_args(
    List<String> includeKeys,
    List<String> excludeKeys,
    ByteBuffer inputData,
    CubeDBFunc classNameOfFilter,
    CubeDBFunc classNameOfConvert,
    CubeDBFunc classNameOfMerge,
    boolean isLocal)
  {
    this();
    this.includeKeys = includeKeys;
    this.excludeKeys = excludeKeys;
    this.inputData = inputData;
    this.classNameOfFilter = classNameOfFilter;
    this.classNameOfConvert = classNameOfConvert;
    this.classNameOfMerge = classNameOfMerge;
    this.isLocal = isLocal;
    setIsLocalIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public combineMultipleFilter_args(combineMultipleFilter_args other) {
    __isset_bit_vector.clear();
    __isset_bit_vector.or(other.__isset_bit_vector);
    if (other.isSetIncludeKeys()) {
      List<String> __this__includeKeys = new ArrayList<String>();
      for (String other_element : other.includeKeys) {
        __this__includeKeys.add(other_element);
      }
      this.includeKeys = __this__includeKeys;
    }
    if (other.isSetExcludeKeys()) {
      List<String> __this__excludeKeys = new ArrayList<String>();
      for (String other_element : other.excludeKeys) {
        __this__excludeKeys.add(other_element);
      }
      this.excludeKeys = __this__excludeKeys;
    }
    if (other.isSetInputData()) {
      this.inputData = TBaseHelper.copyBinary(other.inputData);
    }
    if (other.isSetClassNameOfFilter()) {
      this.classNameOfFilter = new CubeDBFunc(other.classNameOfFilter);
    }
    if (other.isSetClassNameOfConvert()) {
      this.classNameOfConvert = new CubeDBFunc(other.classNameOfConvert);
    }
    if (other.isSetClassNameOfMerge()) {
      this.classNameOfMerge = new CubeDBFunc(other.classNameOfMerge);
    }
    this.isLocal = other.isLocal;
  }

  public combineMultipleFilter_args deepCopy() {
    return new combineMultipleFilter_args(this);
  }

  @java.lang.Override
  public void clear() {
    this.includeKeys = null;
    this.excludeKeys = null;
    this.inputData = null;
    this.classNameOfFilter = null;
    this.classNameOfConvert = null;
    this.classNameOfMerge = null;
    setIsLocalIsSet(false);
    this.isLocal = false;
  }

  public int getIncludeKeysSize() {
    return (this.includeKeys == null) ? 0 : this.includeKeys.size();
  }

  public java.util.Iterator<String> getIncludeKeysIterator() {
    return (this.includeKeys == null) ? null : this.includeKeys.iterator();
  }

  public void addToIncludeKeys(String elem) {
    if (this.includeKeys == null) {
      this.includeKeys = new ArrayList<String>();
    }
    this.includeKeys.add(elem);
  }

  public List<String> getIncludeKeys() {
    return this.includeKeys;
  }

  public combineMultipleFilter_args setIncludeKeys(List<String> includeKeys) {
    this.includeKeys = includeKeys;
    
    return this;
  }

  public void unsetIncludeKeys() {
    this.includeKeys = null;
  }

  /** Returns true if field includeKeys is set (has been asigned a value) and false otherwise */
  public boolean isSetIncludeKeys() {
    return this.includeKeys != null;
  }

  public void setIncludeKeysIsSet(boolean value) {
    if (!value) {
      this.includeKeys = null;
    }
  }

  public int getExcludeKeysSize() {
    return (this.excludeKeys == null) ? 0 : this.excludeKeys.size();
  }

  public java.util.Iterator<String> getExcludeKeysIterator() {
    return (this.excludeKeys == null) ? null : this.excludeKeys.iterator();
  }

  public void addToExcludeKeys(String elem) {
    if (this.excludeKeys == null) {
      this.excludeKeys = new ArrayList<String>();
    }
    this.excludeKeys.add(elem);
  }

  public List<String> getExcludeKeys() {
    return this.excludeKeys;
  }

  public combineMultipleFilter_args setExcludeKeys(List<String> excludeKeys) {
    this.excludeKeys = excludeKeys;
    
    return this;
  }

  public void unsetExcludeKeys() {
    this.excludeKeys = null;
  }

  /** Returns true if field excludeKeys is set (has been asigned a value) and false otherwise */
  public boolean isSetExcludeKeys() {
    return this.excludeKeys != null;
  }

  public void setExcludeKeysIsSet(boolean value) {
    if (!value) {
      this.excludeKeys = null;
    }
  }

  public byte[] getInputData() {
    setInputData(TBaseHelper.rightSize(inputData));
    return inputData.array();
  }

  public ByteBuffer BufferForInputData() {
    return inputData;
  }

  public combineMultipleFilter_args setInputData(byte[] inputData) {
    setInputData(ByteBuffer.wrap(inputData));
    return this;
  }

  public combineMultipleFilter_args setInputData(ByteBuffer inputData) {
    this.inputData = inputData;
    
    return this;
  }

  public void unsetInputData() {
    this.inputData = null;
  }

  /** Returns true if field inputData is set (has been asigned a value) and false otherwise */
  public boolean isSetInputData() {
    return this.inputData != null;
  }

  public void setInputDataIsSet(boolean value) {
    if (!value) {
      this.inputData = null;
    }
  }

  public CubeDBFunc getClassNameOfFilter() {
    return this.classNameOfFilter;
  }

  public combineMultipleFilter_args setClassNameOfFilter(CubeDBFunc classNameOfFilter) {
    this.classNameOfFilter = classNameOfFilter;
    
    return this;
  }

  public void unsetClassNameOfFilter() {
    this.classNameOfFilter = null;
  }

  /** Returns true if field classNameOfFilter is set (has been asigned a value) and false otherwise */
  public boolean isSetClassNameOfFilter() {
    return this.classNameOfFilter != null;
  }

  public void setClassNameOfFilterIsSet(boolean value) {
    if (!value) {
      this.classNameOfFilter = null;
    }
  }

  public CubeDBFunc getClassNameOfConvert() {
    return this.classNameOfConvert;
  }

  public combineMultipleFilter_args setClassNameOfConvert(CubeDBFunc classNameOfConvert) {
    this.classNameOfConvert = classNameOfConvert;
    
    return this;
  }

  public void unsetClassNameOfConvert() {
    this.classNameOfConvert = null;
  }

  /** Returns true if field classNameOfConvert is set (has been asigned a value) and false otherwise */
  public boolean isSetClassNameOfConvert() {
    return this.classNameOfConvert != null;
  }

  public void setClassNameOfConvertIsSet(boolean value) {
    if (!value) {
      this.classNameOfConvert = null;
    }
  }

  public CubeDBFunc getClassNameOfMerge() {
    return this.classNameOfMerge;
  }

  public combineMultipleFilter_args setClassNameOfMerge(CubeDBFunc classNameOfMerge) {
    this.classNameOfMerge = classNameOfMerge;
    
    return this;
  }

  public void unsetClassNameOfMerge() {
    this.classNameOfMerge = null;
  }

  /** Returns true if field classNameOfMerge is set (has been asigned a value) and false otherwise */
  public boolean isSetClassNameOfMerge() {
    return this.classNameOfMerge != null;
  }

  public void setClassNameOfMergeIsSet(boolean value) {
    if (!value) {
      this.classNameOfMerge = null;
    }
  }

  public boolean isIsLocal() {
    return this.isLocal;
  }

  public combineMultipleFilter_args setIsLocal(boolean isLocal) {
    this.isLocal = isLocal;
    setIsLocalIsSet(true);

    return this;
  }

  public void unsetIsLocal() {
  __isset_bit_vector.clear(__ISLOCAL_ISSET_ID);
  }

  /** Returns true if field isLocal is set (has been asigned a value) and false otherwise */
  public boolean isSetIsLocal() {
    return __isset_bit_vector.get(__ISLOCAL_ISSET_ID);
  }

  public void setIsLocalIsSet(boolean value) {
    __isset_bit_vector.set(__ISLOCAL_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case INCLUDE_KEYS:
      if (value == null) {
        unsetIncludeKeys();
      } else {
        setIncludeKeys((List<String>)value);
      }
      break;
    case EXCLUDE_KEYS:
      if (value == null) {
        unsetExcludeKeys();
      } else {
        setExcludeKeys((List<String>)value);
      }
      break;
    case INPUT_DATA:
      if (value == null) {
        unsetInputData();
      } else {
        setInputData((ByteBuffer)value);
      }
      break;
    case CLASS_NAME_OF_FILTER:
      if (value == null) {
        unsetClassNameOfFilter();
      } else {
        setClassNameOfFilter((CubeDBFunc)value);
      }
      break;
    case CLASS_NAME_OF_CONVERT:
      if (value == null) {
        unsetClassNameOfConvert();
      } else {
        setClassNameOfConvert((CubeDBFunc)value);
      }
      break;
    case CLASS_NAME_OF_MERGE:
      if (value == null) {
        unsetClassNameOfMerge();
      } else {
        setClassNameOfMerge((CubeDBFunc)value);
      }
      break;
    case IS_LOCAL:
      if (value == null) {
        unsetIsLocal();
      } else {
        setIsLocal((Boolean)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case INCLUDE_KEYS:
      return getIncludeKeys();
    case EXCLUDE_KEYS:
      return getExcludeKeys();
    case INPUT_DATA:
      return getInputData();
    case CLASS_NAME_OF_FILTER:
      return getClassNameOfFilter();
    case CLASS_NAME_OF_CONVERT:
      return getClassNameOfConvert();
    case CLASS_NAME_OF_MERGE:
      return getClassNameOfMerge();
    case IS_LOCAL:
      return new Boolean(isIsLocal());
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case INCLUDE_KEYS:
      return isSetIncludeKeys();
    case EXCLUDE_KEYS:
      return isSetExcludeKeys();
    case INPUT_DATA:
      return isSetInputData();
    case CLASS_NAME_OF_FILTER:
      return isSetClassNameOfFilter();
    case CLASS_NAME_OF_CONVERT:
      return isSetClassNameOfConvert();
    case CLASS_NAME_OF_MERGE:
      return isSetClassNameOfMerge();
    case IS_LOCAL:
      return isSetIsLocal();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof combineMultipleFilter_args)
      return this.equals((combineMultipleFilter_args)that);
    return false;
  }

  public boolean equals(combineMultipleFilter_args that) {
    if (that == null)
      return false;
    boolean this_present_includeKeys = true && this.isSetIncludeKeys();
    boolean that_present_includeKeys = true && that.isSetIncludeKeys();
    if (this_present_includeKeys || that_present_includeKeys) {
      if (!(this_present_includeKeys && that_present_includeKeys))
        return false;
      if (!this.includeKeys.equals(that.includeKeys))
        return false;
    }
    boolean this_present_excludeKeys = true && this.isSetExcludeKeys();
    boolean that_present_excludeKeys = true && that.isSetExcludeKeys();
    if (this_present_excludeKeys || that_present_excludeKeys) {
      if (!(this_present_excludeKeys && that_present_excludeKeys))
        return false;
      if (!this.excludeKeys.equals(that.excludeKeys))
        return false;
    }
    boolean this_present_inputData = true && this.isSetInputData();
    boolean that_present_inputData = true && that.isSetInputData();
    if (this_present_inputData || that_present_inputData) {
      if (!(this_present_inputData && that_present_inputData))
        return false;
      if (!this.inputData.equals(that.inputData))
        return false;
    }
    boolean this_present_classNameOfFilter = true && this.isSetClassNameOfFilter();
    boolean that_present_classNameOfFilter = true && that.isSetClassNameOfFilter();
    if (this_present_classNameOfFilter || that_present_classNameOfFilter) {
      if (!(this_present_classNameOfFilter && that_present_classNameOfFilter))
        return false;
      if (!this.classNameOfFilter.equals(that.classNameOfFilter))
        return false;
    }
    boolean this_present_classNameOfConvert = true && this.isSetClassNameOfConvert();
    boolean that_present_classNameOfConvert = true && that.isSetClassNameOfConvert();
    if (this_present_classNameOfConvert || that_present_classNameOfConvert) {
      if (!(this_present_classNameOfConvert && that_present_classNameOfConvert))
        return false;
      if (!this.classNameOfConvert.equals(that.classNameOfConvert))
        return false;
    }
    boolean this_present_classNameOfMerge = true && this.isSetClassNameOfMerge();
    boolean that_present_classNameOfMerge = true && that.isSetClassNameOfMerge();
    if (this_present_classNameOfMerge || that_present_classNameOfMerge) {
      if (!(this_present_classNameOfMerge && that_present_classNameOfMerge))
        return false;
      if (!this.classNameOfMerge.equals(that.classNameOfMerge))
        return false;
    }
    boolean this_present_isLocal = true;
    boolean that_present_isLocal = true;
    if (this_present_isLocal || that_present_isLocal) {
      if (!(this_present_isLocal && that_present_isLocal))
        return false;
      if (this.isLocal != that.isLocal)
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_includeKeys = true && (isSetIncludeKeys());
    builder.append(present_includeKeys);
    if (present_includeKeys)
      builder.append(includeKeys);
    boolean present_excludeKeys = true && (isSetExcludeKeys());
    builder.append(present_excludeKeys);
    if (present_excludeKeys)
      builder.append(excludeKeys);
    boolean present_inputData = true && (isSetInputData());
    builder.append(present_inputData);
    if (present_inputData)
      builder.append(inputData);
    boolean present_classNameOfFilter = true && (isSetClassNameOfFilter());
    builder.append(present_classNameOfFilter);
    if (present_classNameOfFilter)
      builder.append(classNameOfFilter);
    boolean present_classNameOfConvert = true && (isSetClassNameOfConvert());
    builder.append(present_classNameOfConvert);
    if (present_classNameOfConvert)
      builder.append(classNameOfConvert);
    boolean present_classNameOfMerge = true && (isSetClassNameOfMerge());
    builder.append(present_classNameOfMerge);
    if (present_classNameOfMerge)
      builder.append(classNameOfMerge);
    boolean present_isLocal = true;
    builder.append(present_isLocal);
    if (present_isLocal)
      builder.append(isLocal);
    return builder.toHashCode();
  }

  public int compareTo(combineMultipleFilter_args other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    combineMultipleFilter_args typedOther = (combineMultipleFilter_args)other;

    lastComparison = Boolean.valueOf(isSetIncludeKeys()).compareTo(typedOther.isSetIncludeKeys());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetIncludeKeys()) {
      lastComparison = TBaseHelper.compareTo(this.includeKeys, typedOther.includeKeys);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetExcludeKeys()).compareTo(typedOther.isSetExcludeKeys());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetExcludeKeys()) {
      lastComparison = TBaseHelper.compareTo(this.excludeKeys, typedOther.excludeKeys);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetInputData()).compareTo(typedOther.isSetInputData());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetInputData()) {
      lastComparison = TBaseHelper.compareTo(this.inputData, typedOther.inputData);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClassNameOfFilter()).compareTo(typedOther.isSetClassNameOfFilter());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClassNameOfFilter()) {
      lastComparison = TBaseHelper.compareTo(this.classNameOfFilter, typedOther.classNameOfFilter);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClassNameOfConvert()).compareTo(typedOther.isSetClassNameOfConvert());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClassNameOfConvert()) {
      lastComparison = TBaseHelper.compareTo(this.classNameOfConvert, typedOther.classNameOfConvert);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClassNameOfMerge()).compareTo(typedOther.isSetClassNameOfMerge());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClassNameOfMerge()) {
      lastComparison = TBaseHelper.compareTo(this.classNameOfMerge, typedOther.classNameOfMerge);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetIsLocal()).compareTo(typedOther.isSetIsLocal());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetIsLocal()) {
      lastComparison = TBaseHelper.compareTo(this.isLocal, typedOther.isLocal);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 1: // INCLUDE_KEYS
          if (field.type == TType.LIST) {
            {
            TList _list31 = iprot.readListBegin();
            this.includeKeys = new ArrayList<String>(_list31.size);
            for (int _i32 = 0; _i32 < _list31.size; ++_i32)
            {
              String _elem33;
              _elem33 = iprot.readString();
              this.includeKeys.add(_elem33);
            }
            iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // EXCLUDE_KEYS
          if (field.type == TType.LIST) {
            {
            TList _list34 = iprot.readListBegin();
            this.excludeKeys = new ArrayList<String>(_list34.size);
            for (int _i35 = 0; _i35 < _list34.size; ++_i35)
            {
              String _elem36;
              _elem36 = iprot.readString();
              this.excludeKeys.add(_elem36);
            }
            iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 3: // INPUT_DATA
          if (field.type == TType.STRING) {
            this.inputData = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 4: // CLASS_NAME_OF_FILTER
          if (field.type == TType.STRUCT) {
            this.classNameOfFilter = new CubeDBFunc();
            this.classNameOfFilter.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 5: // CLASS_NAME_OF_CONVERT
          if (field.type == TType.STRUCT) {
            this.classNameOfConvert = new CubeDBFunc();
            this.classNameOfConvert.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 6: // CLASS_NAME_OF_MERGE
          if (field.type == TType.STRUCT) {
            this.classNameOfMerge = new CubeDBFunc();
            this.classNameOfMerge.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 7: // IS_LOCAL
          if (field.type == TType.BOOL) {
            this.isLocal = iprot.readBool();
            setIsLocalIsSet(true);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    validate();
    
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.includeKeys != null) {
      oprot.writeFieldBegin(INCLUDE_KEYS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.includeKeys.size()));
        for (String _iter37 : this.includeKeys)
        {
          oprot.writeString(_iter37);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.excludeKeys != null) {
      oprot.writeFieldBegin(EXCLUDE_KEYS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.excludeKeys.size()));
        for (String _iter38 : this.excludeKeys)
        {
          oprot.writeString(_iter38);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.inputData != null) {
      oprot.writeFieldBegin(INPUT_DATA_FIELD_DESC);
      oprot.writeBinary(this.inputData);
      oprot.writeFieldEnd();
    }
    if (this.classNameOfFilter != null) {
      oprot.writeFieldBegin(CLASS_NAME_OF_FILTER_FIELD_DESC);
      this.classNameOfFilter.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.classNameOfConvert != null) {
      oprot.writeFieldBegin(CLASS_NAME_OF_CONVERT_FIELD_DESC);
      this.classNameOfConvert.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.classNameOfMerge != null) {
      oprot.writeFieldBegin(CLASS_NAME_OF_MERGE_FIELD_DESC);
      this.classNameOfMerge.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(IS_LOCAL_FIELD_DESC);
    oprot.writeBool(this.isLocal);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("combineMultipleFilter_args(");
    boolean first = true;
    sb.append("includeKeys:");
    if (this.includeKeys == null) {
      sb.append("null");
    } else {
      sb.append(this.includeKeys);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("excludeKeys:");
    if (this.excludeKeys == null) {
      sb.append("null");
    } else {
      sb.append(this.excludeKeys);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("inputData:");
    if (this.inputData == null) {
      sb.append("null");
    } else {
      TBaseHelper.toString(this.inputData, sb);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("classNameOfFilter:");
    if (this.classNameOfFilter == null) {
      sb.append("null");
    } else {
      sb.append(this.classNameOfFilter);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("classNameOfConvert:");
    if (this.classNameOfConvert == null) {
      sb.append("null");
    } else {
      sb.append(this.classNameOfConvert);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("classNameOfMerge:");
    if (this.classNameOfMerge == null) {
      sb.append("null");
    } else {
      sb.append(this.classNameOfMerge);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("isLocal:");
    sb.append(this.isLocal);
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}


  public static class combineMultipleFilter_result implements TBase<combineMultipleFilter_result, combineMultipleFilter_result._Fields>, java.io.Serializable, Cloneable {
  private static final TStruct STRUCT_DESC = new TStruct("combineMultipleFilter_result");

  private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);


  public CombineGetResult success;

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements TFieldIdEnum {
    SUCCESS((short)0, "success");
  
    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
  
    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 0: // SUCCESS
          return SUCCESS;
        default:
          return null;
      }
    }
  
    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }
  
    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }
  
    private final short _thriftId;
    private final String _fieldName;
  
    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }
  
    public short getThriftFieldId() {
      return _thriftId;
    }
  
    public String getFieldName() {
      return _fieldName;
    }
  }


  // isset id assignments

  public static final Map<_Fields, FieldMetaData> metaDataMap;
  static {
    Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
      new StructMetaData(TType.STRUCT, CombineGetResult.class)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    FieldMetaData.addStructMetaDataMap(combineMultipleFilter_result.class, metaDataMap);
  }


  public combineMultipleFilter_result() {
  }

  public combineMultipleFilter_result(
    CombineGetResult success)
  {
    this();
    this.success = success;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public combineMultipleFilter_result(combineMultipleFilter_result other) {
    if (other.isSetSuccess()) {
      this.success = new CombineGetResult(other.success);
    }
  }

  public combineMultipleFilter_result deepCopy() {
    return new combineMultipleFilter_result(this);
  }

  @java.lang.Override
  public void clear() {
    this.success = null;
  }

  public CombineGetResult getSuccess() {
    return this.success;
  }

  public combineMultipleFilter_result setSuccess(CombineGetResult success) {
    this.success = success;
    
    return this;
  }

  public void unsetSuccess() {
    this.success = null;
  }

  /** Returns true if field success is set (has been asigned a value) and false otherwise */
  public boolean isSetSuccess() {
    return this.success != null;
  }

  public void setSuccessIsSet(boolean value) {
    if (!value) {
      this.success = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        setSuccess((CombineGetResult)value);
      }
      break;
    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case SUCCESS:
      return getSuccess();
    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case SUCCESS:
      return isSetSuccess();
    }
    throw new IllegalStateException();
  }

  @java.lang.Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof combineMultipleFilter_result)
      return this.equals((combineMultipleFilter_result)that);
    return false;
  }

  public boolean equals(combineMultipleFilter_result that) {
    if (that == null)
      return false;
    boolean this_present_success = true && this.isSetSuccess();
    boolean that_present_success = true && that.isSetSuccess();
    if (this_present_success || that_present_success) {
      if (!(this_present_success && that_present_success))
        return false;
      if (!this.success.equals(that.success))
        return false;
    }

    return true;
  }

  @java.lang.Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();
    boolean present_success = true && (isSetSuccess());
    builder.append(present_success);
    if (present_success)
      builder.append(success);
    return builder.toHashCode();
  }

  public int compareTo(combineMultipleFilter_result other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    combineMultipleFilter_result typedOther = (combineMultipleFilter_result)other;

    lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSuccess()) {
      lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }


  public void read(TProtocol iprot) throws TException {
    TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case 0: // SUCCESS
          if (field.type == TType.STRUCT) {
            this.success = new CombineGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(TProtocol oprot) throws TException {
    oprot.writeStructBegin(STRUCT_DESC);
    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @java.lang.Override
  public String toString() {
    StringBuilder sb = new StringBuilder("combineMultipleFilter_result(");
    boolean first = true;
    sb.append("success:");
    if (this.success == null) {
      sb.append("null");
    } else {
      sb.append(this.success);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws TException {
    // check for required fields
  }
}



}
